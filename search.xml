<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Mac上网络抓包Charles]]></title>
      <url>%2F2016%2F11%2F19%2FMac%E4%B8%8A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Charles.html</url>
      <content type="text"><![CDATA[抓包？就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进行数据截取等。 为什么调试配置Host？ 我们知道在网络上访问网站，要首先通过DNS服务器把网络域名（www.XXXX.com）解析成61.XXX.XXX.XXX的IP地址后，我们的计算机才能访问。要是对于每个域名请求我们都要等待域名服务器解析后返回IP信息，这样访问网络的效率就会降低，而Hosts文件就能提高解析效率。 在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务要输入难记的IP地址，对不少人来说相当麻烦。现在可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候我们输入这个服务器的名字就行了。 对于Lotus的服务器和一些数据库服务器，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。 Charles Mac下常用的网络封包截取工具(免费30天 - 试用期过后建议购买正版) Charles通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析 Charles主要功能 截取Http和Https网络封包。 支持重发网络请求，方便前后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟满网速网络 安装步骤下载好Charles - 打开下载包( .dmg后缀的文件 )后将Charles拖到Application目录下即可。 启动Charles后、第一次Charles会请求您给它设置系统代理的权限。图例如下！ 源： 译： Firefox代理服务器配置 源： 译： 在Firefox中打开 https://addons.mozilla.org/zh-CN/firefox/addon/charles-proxy/ 源： 译： 这样在Firefox可以抓包Proxy -&gt; Mozilla Firefox Proxy 将Charles设置成系统代理Charles主界面 Structure：结构( 视图将网络请求按访问的域名分类 ) Sequence：先后次序( 视图将网络请求按访问的时间排序 ) 根据具体的需求在这两个视图之间来回切换、大多数情况下截获的请求会很多，Charles提供了一个简单Filter功能，可以输入关键字来快速筛选URL中带指定关键字的网络请求 对于具体的网络请求 若请求的内容是POST表单、Charles会自动将表单进行分项显示 若是JSON格式的内容、Charles会自动将JSON内容格式化 若是图片、Charles会显示出图片的预览 抓包工具之断点修改( 重点 ) 更改返回数据来测试临界情况：这种做法可以让一个前端开发人员独立完成测试而不用拉一个后端一起联调，并且各种特殊维度，临界点都可以独立完成。仅仅自己在青花瓷上改来改去就可以达到效果了。 在实际的工作中、你可以经常用来把某些值改为临界情况 - 以查看当前页面在处理这些临界状况收的反应、这样比(找后端联调\找临界点的测试账号)这些数据成本要低得多， 截获IPhone上的网络封包 Charles通常用来截获本地上的网络封包、当我们需要时、可以用来截取其他设备上的网络请求，如下 截取IPhone上的网络请求、首先打开Charles的代理功能Proxy -&gt; Proxy Settings填入代理端口8888 并勾选&quot;Enable transparent HTTP proxying&quot; 完成在Charles上的设置 在手机上&quot;设置&quot; -&gt; &quot;无线局域网&quot; 找到当前链接的WIFI名、点击右侧详情( 感叹号 )，在最底部找到HTTP代理、修改成手动 设置 - 无线局域网 服务器：当前Charles运行所在电脑的IP：系统偏好设置 -&gt; 网络 选中现在连着的网（大部分人应该都是WiFi吧） ​ 服务器 ： 电脑IP地址 ，端口号: 8888， 设置完成后、打开iphone上的任意与需要网络的软件、就可以在Charles上看到弹出如下信息,点击&quot;Allow&quot;即可完成设置 - 这是会有一大波抓包信息的展示 模拟慢速网络 在开发时、我们常常需要模拟慢网速或者高延迟的网络、以测试在移动网络下、开发的产品是否显示正常 在Charles菜单中，选择&quot;Proxy - Throttle Setting&quot;在之后弹出的对话框中、勾选上&quot;Enable Throttling&quot;,并且可以设置不同网速的类型如下 修改网络请求内容 有时候伪类调试服务器的接口、我们需要反复尝试不同的参数的网络请求，Charles可以很方便的提供网络请求的修改和重发功能、在网络请求上点击右键,选择&quot;Edit&quot;,即可编辑 我们可以修改请求的任何信息 URL地址 端口号 参数 等等 之后点击&quot;Execute&quot;即可发送该修改后的网络请求。Charles支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面操作iFrame的Dom]]></title>
      <url>%2F2016%2F11%2F18%2F%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9CiFrame%E7%9A%84Dom.html</url>
      <content type="text"><![CDATA[没有过时的技术只有变态的需求 contentWindow兼容主流浏览器、获取子窗口的window对象; 指定的frame或iframe所在的window对象 document对象是window对象的一个子对象; 123456789101112131415document.getElementById('iframe ID').contentWindow.document来获取iframe的document对象。相当于contentDocument属性document.getElementById('userIframe').onload = function()&#123;&#125;window.onload = function()&#123; // (LEPass &amp;&amp; LEPass.isLogin) 登录返回true、没登录放回false document.getElementById('userIframe').contentDocument.body.onclick = function(a)&#123; if(a.target.className == 'ntscshen' &amp;&amp; !(LEPass &amp;&amp; LEPass.isLogin()))&#123; // 登录内容信息 LEPass.openLoginPage(window.location.href, '', &#123; ... ... &#125;); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Atom编辑器的使用技巧]]></title>
      <url>%2F2016%2F10%2F08%2FAtom%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html</url>
      <content type="text"><![CDATA[在Atom中快速打开命令行实际开发的痛点：经常从编辑器切换到命令行( 虽然可以使用CmdTap类似的工具 )、但找到当前目录是需要花费很多时间 apm install open-terminal-here 打开当前项目的顶级目录alt-cmd-t 打开当前文件所在的位置ctrl-cmd-t 在Atom中新建文件、重命名、移动advanced-open-file alt-cmd-o 新建文件 shift-cmd-p rename重命名文件 ctrl-0 m 修改 a 添加文件 shift-a 添加文件夹 d 复制 自定义snippets.cson atom-ternjs Atom快捷键的使用关闭标签后 - 后悔ctrl-shift-t 样式表修改 Atom styless 树形视图的修改和浏览 cmd-\ 打开关闭树形试图( cmd-k-b ) 转移视图光标( ctrl-0 ) ctrl-[ 展开收缩 树形视图 ] ctrl-alt[ 递归展开收缩 ] J向上 k向下 展开目录 L 收起目录H 添加文件和目录 ctrl - 0 - add ( a ) 创建时候可以建立对应目录下的文件夹 ctrl-0 shift-a 创建目录 移动和重命名、复制粘贴删除 ctrl-0 move( m ) 移动到对应的文件目录下、可以用来重命名文件或者目录 duplicate( d )复制 APM 是atom package menage atom包管理工具 可以让用户在命令行下安装跟新删除编辑器的package apm search color 在命令行中显示对应的包 apm home color-picker 使用默认的浏览器打开对应包的首页 apm list包列表 Community packages 社区包 Built-in Atom packages Atom内置包 Snippets代码片段 alt+shift+s代码片段的介绍和一些简写形式 ATOM插件 - Community packages atom汉化atom-simplified-chinese-menu插件 tool bar插件 atom-ternjs JavaScript和Node自动补全插件 - 必备 highlight-selected 高亮所有和当前选中单词一样的单词，IDE标配。 autocomplete-paths 路径补全插件 linter** 和 linter-eslint** linter-eslint依赖linter，安装之后就可以按照.eslintrc文件里面配置校验JS了。 UI file-icons 高颜值的文件图标 pigments 代码颜色可视化修改颜色位置 Marker TYpe: dot indent-guide-improved 代码大括号范围提示。 minimap 类sublime的小地图功能 fold-comments 注释快速折叠 ctrl-shift-/ 快速注释会打出 顿号 elastic-tabstops 弹性制表位 highlight-selected 高亮所有和当前选中单词一样的单词 quick-highlight 高亮、同时高亮多处非选中的单词，在读代码时挺有用 highlight-line 高亮当前行 ​ IDE功能补全 emmet atom-ternjs 提供了了比较精确的代码补全功能ECMAScript、DOM/BOM、NodeJS autocomplete-paths 路径补全 advanced-open-file 翻遍的打开创建文件 cmd+alt+o autoclose-html 自动闭合标签 atom-beautify 代码美化、自己支持的语法不多、语法例如 PHP、MarkDown、Python 则需系统安装一些额外的插件 editorconfig 空格和utf-8、EditorConfig帮助开发人员保持不同的编辑器之间是一致的编码风格 Run In Browser 打开浏览器 ctrl + alt + r Bracket Matcher 括号匹配 docblockr 注释 autocomplete-emojis 表情包 Open Terminal Here 打开当前文件命令行 当前目录终端ctrl-cmd-t 项目目录终端alt-cmd-t regex-railroad-diagram package 正则 Activate Power Mode 爆炸 css-snippets javascript-snippets jQuery-snippets command palette dev live reload ​ Markdown markdown-assistant 剪切板上传图片 qiniu-uploader 七牛图床 markdown-listsMarkdown常见的用法 h1-h6 有序列表: * 、 无序列表: - 引用 &gt; 图片img、加粗b、倾斜i 表格table 代码段code React hyperclick 可以跳转到变量定义的地方，也能识别import/require，点击模块名可以跳转到模块的内部。 js-hyperclick 配合 hyperclick 使用 Atom全局配置ESLinthttp://wrox.cn/article/100077190/ linter 和 linter-eslint]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端基础事件（一）]]></title>
      <url>%2F2016%2F09%2F22%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%BA%8B%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="text"><![CDATA[移动端事件 touchstart 手指触摸屏幕时候触发 touched 手指离开屏幕时候触发 touchmove 手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。 addEventListener(‘事件名’,函数[匿名OR有名],false[冒泡和捕获]); DOM中提供的注册事件监听器的方法 它允许给一个事件注册多个监听器。不会存在前后覆盖问题 在Chrome的模拟器下可以一直识别 Event 事件对象、事件函数中默认的第一个参数 cancelBubble(取消冒泡) 阻止冒泡console.dir(event); target(标靶) 事件发生的位置console.dir(event); e.preventDefault();阻止默认事件 阻止页面中的文字选中 阻止页面上的系统菜单、滚动条失效、overflow: auto;失效 事件穿透 PC鼠标事件、但事件的执行会有300ms的延迟 点击了页面之后 - 浏览器会记录点击下去的坐标 300ms后、在该坐标找到现在在这的元素 - 执行事件 解决办法 e.preventDefault(); 阻止默认事件 不在移动端使用鼠标事件 不用a标签做页面跳转(点透问题、防止误触a标签)、把a标签的href的跳转e.preventDefault() 12345678910111213141516// 误触 document.addEventListener('touchstart', function(e) &#123; e.preventDefault(); &#125;) function mistake() &#123; this.isMove = true; &#125; var aBlock = document.querySelectorAll('a'); aBlock[0].addEventListener('touchmove', mistake, false); aBlock[0].addEventListener('touchend', function() &#123; if (!this.isMove) &#123; window.location.href = 'http://www.baidu.com'; &#125; this.isMove = false; &#125;, false);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之 - 单体模式]]></title>
      <url>%2F2016%2F09%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%20-%20%E5%8D%95%E4%BD%93%E6%A8%A1%E5%BC%8F.html</url>
      <content type="text"><![CDATA[单体模式 - 比其他任何模式都更常用 特点和定义: 把描述同一件事务特征的属性放在同一个分组中、避免两个事务属性的冲突。( 将代码组织为一个逻辑单元、这个逻辑单元可以通过单一的变量进行访问 ) 划分命名空间、减少网页中全局变量的数目 跟重要的是、可以把代码组织的更为一致、使其跟容易阅读和维护 因为JS是单线程运行、单例模式看起来好像没什么用处、唯一的作用可能就是用来避免混乱 - 在各个命名空间之间 单体对象和普通对象字面量的区别 按照传统的定义( 单体模式 )：①单体是一个只能被实例化一次②并且可以通过一个众所周知的访问点访问的类 1234567891011121314151617// 最简单的单例模式// 就是一些个简单的方法和属性的对象字面量(給变量赋值时、等号右边都可以认为是字面量)、假设他们是因为某种关系才被放到一起的/** * Basic Singleton * Basic 基础的 * Singleton 单独 Sin狗ten * attribute 属性、特性 * method 方法 */var Singleton = &#123; attribute1: true, attribute2: 10, method1: function()&#123;&#125;, method2: function()&#123;&#125;&#125;// 若严格的按照定义来说、这个例子并不是一个单体模式、因为它不是一个可实例化的类// 并非所有的字面量都是单体、如果它用来组织相关方法和属性的话、那它就是单体。。。其主要的区别在于设计者的意图 javascript中的单体定义：单体是一个①用来划分命名空间并②将一批相关方法和属性组织在一起的对象，③如果它可以被实例化、那么它只能被实例化一次 1234567891011121314151617var person1 = &#123; name: "ntscshen", age: 23, check: function()&#123;&#125;, submit: function()&#123;&#125;&#125;var person2 = &#123; name: "ntscshen2", age: 24, check: function()&#123; this.submit();// 在自己的命名空间中调用自己的方法 &#125;, submit: function()&#123; person1.check();// 在自己的命名空间中调用其他命名空间下的方法 &#125;&#125;// person1和person2叫做命名空间 Javascript模块化和命名空间管理1234567891011// 我们通常用一个全局变量或者全局对象来作为我们的namespace// 在做一些中小型项目的时候、使用这种简单、随便的方式、工作是足够了、基本不会出现什么大的乱子var Namespace = &#123;&#125;;;(function()&#123; Namespace.Class1 = function()&#123; // TODO &#125;, Namespace.Class2 = function()&#123; // TODO &#125;&#125;)(); 简单的通过全局对象来作namespace能够很好的减少全局变量、规避变量名污染问题。 由于这些成员只能通过这个单体对象变量进行访问、因此在某种意义上、可以说他们被单体对象圈在了一个命名空间中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * 在单体对象内创建私有成员的最简单、最直截了当的办法是使用下划线表示法 *//** * 使用闭包的方式、可以用来添加真正的私有成员闭包 * 而不需要使用"_"下划线的。人肉方法 * 这种使用函数自执行的单体模式又称作为"模块模式"、指的是它可以 * 把一批相关方法和属性组织为模块并起到划分命名空间的作用 * private members * private 私人的 * members 成员 */MyNamespace.Singleton = (function()&#123; // private members var privateAttribute1 = false; var privateAttribute2 = [1,2,3]; function privateMethod1()&#123;&#125; function privateMethod2()&#123;&#125; // Public members return &#123; publicAttribute1: true, publicAttribute2: 10, publicMethod1: function()&#123;&#125;, publicMethod2: function()&#123;&#125; &#125;;&#125;)();/** * 两种命名私有变量的方法 * 1、不必再每个私用方法名称的开头添加一个下划线、而是把这个方法定义在闭包中 * 2、现在这些私用方法和属性可以直接用其名称访问、不必再其前面加上"this" * 或"GiantCorp.DataParser",这些前缀只能用于访问单体对象的公共成员 * 3、使用这种模式、可以真正的享受到私用成员带来的所有好处、不必付出什么代价 * 因为单例类只会被实例化一次 *//** * 堕性实例化 * 无论是简单的"对象字面量"的单体方式、还是使用闭包的方式创建都有一个共同特点 * 1、单体对象都是在脚本加载时被创建出来 * 2、对于资源密集型或配置开销很大的单体、也许更合适的做法是将其实例化推迟 * 到需要使用的时候加载、这种技术称之为"惰性加载" lazy loading * 常用于"必须加载大量"数据的单体 * 3、而那些命名空间、相关使用方法的工具单体最好立即实例化 * 惰性加载单体需要借助一个静态方法、Singleton.getInstance().methodName() * getInstance方法会检查该单体是否已经被实例化、如果没有、那么它将创建并返回实例 * 如果单体已经实例化过了、那么它将返回实例 */// 把普通单体 - 转换为 - 惰性加载单体// 1、把单体的所有代码应道一个名为constructor的方法中// 2、MyNamespace.Singleton = (function()&#123; var uniqueInstance;// 唯一的实例 function constructor()&#123; // Private members var privateAttribute1 = false; var privateAttribute2 = [1,2,3]; function privateMethod1()&#123;&#125; function privateMethod2()&#123;&#125; // Public members return &#123; publicAttribute1: true, publicAttribute2: 10, publicMethod1: function()&#123;&#125;, publicMethod2: function()&#123;&#125; &#125; &#125; // instance 实例 return &#123; getInstance: function()&#123; if(!uniqueInstance)&#123; uniqueInstance = constructor(); &#125; return uniqueInstance; &#125; &#125;&#125;)();/** * 编写控制单例类实例化时机的代码 * 1、它必须知道该类是否已经被实例化 * 2、如果该类已经实例化过、那么它需要掌握其实例化的情况、以便返回这个实例 * 普通单体模式修改成惰性单体后、调用它的单体代码必须进行修改 * MyNamespace.Singleton.publicMethod1(); * 修改成如下形式 * MyNamespace.Singleton.getInstance().publicMethod1(); * * 惰性加载单体的缺点之一是其复杂、不直观、并且不好理解 * 如果你需要创建一个延迟实例化的单体、那么最好为其编写一条注释解释这样做的原因 * 以免别人把它简化为普通单体 * 如果觉得命名空间名称太长、可以创建一个别名简化它、这种别名只不过是 * 一个保存了对特定对象的引用的变量 * var MNS = MyNamespace.Singleton; */ 单体模式的使用场合 从为代码提供 命名空间 和 增强其 模块性 的角度来说、应该竟可能多的使用 JavaScript中最常用的模式之一、几乎适用于所有的大大小小的项目 在简单的快餐项目中、可以把单体用作 “命名空间” 、将自己的所有代码组织在一个全局变量下 在稍大、稍复杂一点的项目中、单体用来把相关代码组织在一起一边后期维护或者用来把数据或代码安置在一个众所周知的单一位置 在大型或复杂的项目中、可以起到优化作用、那些开销较大却很少使用的组件可以被包装到惰性加载单体中 单体模式 - 及其重要 - 是因为它可以用来创建命名空间以减少全局变量的数目 JavaScript语言中全局变量比其他语言中跟具危险性、代码编写者形形色色、JS代码五花八门、全局变量和函数很容易被篡改、从而导致代码的失灵、可以解决这种问题的单体模式无疑是前端开发者的一大利器 单体模式之利 主要好处是它对于代码的组织作用。把相关方法和属性组织在一个不会被多个次实例化的单例中、利于调试和维护。防止被其他程序员误改、防止全局命名空间被一大堆变量弄的一团糟、可以把你的代码和第三方库的代码和广告代码隔离开、从而提高网页的稳定性。 单体模式的一些变体可以在开发周期的后期针对脚本进行优化、提示性能 惰性加载、分支技术 单例模式之弊 由于单体模式提供的是一种单点访问、所以它可能导致模块间的强耦合。( 低耦合是指让每个模块尽可能的独立完成某个特定的子功能。 ) 导致类间的强耦合、同样不利于单元测试、你无法单独测试一个调用了来自单体的方法的类、而只能把它与那个单体作为一个单元一起测试。 单体最好还是留给①定义命名空间②实现分支型方法。在这些情况下、耦合才不是什么问题 学会单体是成为一个值得信赖的高级JavaScript程序员所经历的第一步]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面性能管理]]></title>
      <url>%2F2016%2F09%2F01%2F%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86.html</url>
      <content type="text"><![CDATA[网页生成的过程、大致分成五步 第一步到第三幕都非常快( 一刹那 ) “生成布局” - flow - layout(布局) - Render Tree( 渲染树 ) “绘制” - paint flow + paint = render(渲染) 重排和重绘 重绘：元素外观改变所触发的浏览器行为(visibility\outline\背景色) 重排：渲染树重新计算 “重绘”不一定”重排” “重排”必定”重绘” 从性能角度考虑 经量不把 读操作 和 写操作 在一个里面 12345// baddiv.style.left = div.offsetLeft + 10 + "px";// Goodvar left = div.offsetLeft;div.style.left = left + 10 + "px"; 一般规则如下 样式表越简单、重排和重绘就会越快 重排和重绘的DOM元素层级越高、成本就越高 table元素的重排和重绘成本、高于div元素 提高性能的技巧 读操作和写操作、应该放在一起( 不要在两个读操作之间、加入一个写操作 ) 若某个样式是通过重排得到的、把结果缓存下来、避免下一次用到的时候、浏览器重排 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。 不要在JS里一条条的修改样式、要通过改变class或者csstext属性、一次性地改变样式 将元素设置display: none( 需要一次重排和重绘 )、然后对这个几点进行N+次操作、最后再回复显示( 需要一次重排和重绘 )、这样、使用两次重新渲染、取代可能的N+次的重新渲染 position属性为absolute或fixed的元素时候、重排的开销比较小、因为不用考虑它对其他元素的影响 123456// bad var top = 10; ele.style.left = left + "px"; ele.style.top = top + "px"; // Good var top = 10,left = 10; $('ele').css(&#123;left: left,top: top&#125;); css的效率 浏览器读取CSS选择器有一个很重要的原则，它们从右到左读取。这意味这像 ul &gt; li a[title=&quot;home&quot;]这样的选择器， a[title=&quot;home&quot;] 将是最先被读取的。 ID是唯一的、所以不需要任何的标签进行修饰、这样只会让效率更低ul#main{} 没有什么比用后代选择器更糟糕的做法了 后代选择器是css选择器里最昂贵的选择器 总结的优化技巧CSS优化 CSS尽量避免使用后代选择器 - 使用子代选择器代替没有比后代选择器跟糟糕的 在书写CSS时、使用类选择器”代替”元素选择器类选择器获取速度优于元素选择器 样式表越简单、嵌套层级越小( 重排和重绘就会越快 ) sass书写不大于三层 jQuery优化 选择器优化 尽可能使用ID选择器( 唯一的、最快的 )，因为jQuery源码中调用的是document.getElementById()、不要与其他选择器混搭 class选择器次之调用原生getElementByClassName()方法、指定类选择器的上下文、以缩小选择范围(默认：document)$(&#39;.class&#39;,&#39;#div1&#39;); 多级查找中、选择器的子类越详细越好$(&quot;.data li.li1&quot;) $parent.find(‘p.child’) 最快查找子元素的方法find()会调用原生的 getElementByTagName方法 经可能的缓存(缓存比不缓存快了2-3倍) 为什么要缓存得到的变量？就是减少访问DOM接口 使用链式写法、jQuery会自动缓存每一步的结果、链式比不链式写法快了25%左右 DOM优化 如果对一个DOM进行大量处理操作、使用.detach()方法、取出 - 处理 - 插入、使用.detach()方法比不使用时，快了60%。.detach(分离) .detach()移除被选元素，包括所有文本和子节点。这个方法会保留 jQuery 对象中的匹配的元素，因而可以在将来再使用这些匹配的元素。会保留所有绑定的事件、附加的数据。主要为了处理元素的大量DOM操作而生 改动DOM结构、先把它们合并，然后再一次性插入 不要使用匿名函数来用作事件处理、这样不利于调试、测试、维护和服用$(&quot;#btn&quot;).on(&#39;click&#39;,&#39;a&#39;,myClick);function myClick(){...} 在DOM元素上存储数据 123456var ele = $('#ele');ele.data(key,value);// 修改var ele = $('#ele');$.data(ele[0],key,value);// 因为elem.data()方法是定义在jQuery函数的prototype对象上面的，而$.data()方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用 如果可能的话使用自己的事件命名空间、这样方便地取消绑定而不影响其他的DOM元素事件绑定$(&quot;#myClick&quot;).on(&quot;click.ntscshen&quot;,&quot;a&quot;,myEventHandler);$(&quot;#myClick&quot;).off(&quot;click.ntscshen&quot;) 不要处理不存在的元素if($mySelection.length){...} 当某个事件后、如果要连续执行多个操作使用自定义事件并使用自执行事件 123456function shen()&#123; $.trigger('yang');&#125;$(document).on('yang',function()&#123; one();&#125;) 其他的优化方案 在JS内会用添加类名的方式修改”样式”属性不要使用jquery.CSS({方法})、使用添加类名的方式$(&quot;#click&quot;).addClass(&quot;error&quot;); 使用事件委托进行处理的方式就近原则 在注重性能的地方、请使用原生的Javascript代码 当需要大量的DOM操作时、先隐藏在内存中操作、在显示只触发两次重排和重绘操作 定位元素的开销较小、不用考虑对其他元素的影响]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BFC]]></title>
      <url>%2F2016%2F08%2F31%2FBFC.html</url>
      <content type="text"><![CDATA[BFC - 快级格式化上下文 用于决定快盒子的布局及相互影响的区域 浮动 定位absolute OR fixed 行内快级元素display: inline-block 表格单元格display: table-cell 表格标题display: table-caption 切割overflow: hidden; 弹性盒子display: flex OR display: inline-flex 快级格式化上下文对定位和清除浮动很重要 定位和清除浮动的样式规则适用于处于同一个快格式化上下文内的元素 浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只清除同一块格式化上下文中 在它前面的元素的浮动。 BFC布局规则 内部元素会在垂直方向、一个接着一个放置 每个元素的margin box的左边、与包含快border box的左边相接触即使浮动也是如此 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 具体事务 BFC的区域不会与float box重叠 计算BFC的高度时、浮动元素也参与计算 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠上下margin值穿透 自适应两列布局1234567891011121314151617181920.box &#123; position: relative; width: 500px;&#125;.aside &#123; float: left; width: 100px; height: 200px; background-color: red;&#125;.main &#123; overflow: hidden; height: 300px; background-color: pink;&#125;/*overflow: hidden;会生成浮动BFC不会与浮动元素重叠实现自适应布局*/ 清除内部浮动(overflow: hidden;)12/* 计算BFC的高度时、浮动元素也参与计算 *//* 根据这个原理、清除浮动 */ 防止垂直margin重叠(一个BFC内的上下margin会重叠)12345678910111213141516171819/* Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻的Box的margin会发生重叠 */&lt;style&gt; p&#123; width: 200px; height: 200px; background-color: red; &#125; .wrap&#123; overflow: hidden; &#125;&lt;/style&gt;&lt;p&gt;111&lt;/p&gt;&lt;div class="wrap"&gt; &lt;p&gt;222&lt;/p&gt;&lt;/div&gt;/*在一个重叠的元素上包裹一层容器、并触发该容器生成一个BFC两个p标签就不属于同一个BFC、就不会发生重叠*/ BFC内部的元素和外部的元素”绝对”不会相互影响 BFC外部存在浮动时、它不应该影响BFC内部Box的布局、BFC会通过变窄、而不与浮动重叠 两列布局 BFC内部有浮动时、为了不影响外部元素的布局、BFC计算高度时会包括浮动的高度 清除浮动 BFC内部有重叠发生时、为了不影响外部元素的布局、BFC会包含margin值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css居中的几种方案]]></title>
      <url>%2F2016%2F08%2F31%2Fcss%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88.html</url>
      <content type="text"><![CDATA[固定宽高123456789.wrap &#123; width: 200px; height: 200px; background-color: red; position: absolute; left: 50%;top: 50%; margin-left: -100px; margin-top: -100px;&#125; 1234567891011.wrap &#123; width: 50%; height: 50%; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; background-color: yellow;&#125; 1234567891011.wrap &#123; width: 500px; height: 500px; background-color: chartreuse; display: table;&#125;.wrap div&#123; display: table-cell; vertical-align: middle; margin: 0 auto;&#125; 12345678910111213141516171819.box&#123; width: 500px; height: 500px; background-color: red; text-align: red;&#125;.box div&#123; /* 若为快级元素：则修改为display: inilne-block;即可 */ width: 200px; height: 200px; background-color: pink; vertical-align: middle;&#125;.box::after&#123; content:""; width: 1px; line-height: 500px; background-color: yellow;&#125; 不固定宽度123456789101112.box&#123; position: relative; width: 500px; height: 500px; background-color: red;&#125;.box .div1&#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; 12345678.box&#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;&#125; 12345678910111213/* 相对定位 + 浮动 */.box&#123; position: relative; float: left; left: 50%; top: 50%; background-color: yellow;&#125;.box li&#123; position: relative; left: -50%; top: -50%;&#125; 123456789.box&#123; position: absolute; left: 50%; background-color: red;&#125;.box li&#123; position: relative; left: -50%;&#125; 12345678910111213141516171819202122232425262728293031.box &#123; width: 500px; height: 500px; background-color: #77BBDD; /** 各种版本兼容**/ display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex; /** 垂直居中核心、兼容**/ -webkit-box-pack: center;//09版水平居中 -moz-box-pack: center; -ms-flex-pack: center;//过度版(混合版) -webkit-justify-content: center;//12版水平居中 justify-content: center; -webkit-box-align: center;//09版垂直居中 -moz-box-align: center; -ms-flex-align: center;//过度版(混合版) -webkit-align-items: center;//12版垂直居中 align-items: center; width: 0%;//低版本Android的flex-item无法等分 display: block; /* 实则只需三行 display: flex; justify-content: center; align-items: center; */&#125; 居中浮动元素1234567891011.box&#123; position: relative; left: 50%; top: 50%; float: left; margin-left: -100px; margin-top: -100px; width: 200px; height: 200px; background-color: red;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sass总结]]></title>
      <url>%2F2016%2F08%2F31%2FSass%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[变量 痛点：当配置样式时、需要重复修改各种类名的属性、这是是令人恼怒的 解决：类似于JS中的函数封装、哪里用到哪里调用、配置样式只需修改一次 变量定义在规则快之外 - 主样式内容之外 只声明变量其实没啥用处、最终的目的是达到样式可配置 凡是CSS属性的标准值存在的地方、变量都可使用 变量值也可以引用其他变量、通过颗粒度区分、为不同的值取不同的名字、这个规则相当有用 $highlight-color: #efe0ce !default;默认值 - 可配置修改、相当于jQuery的$.extend({},this.defaults,opt),this.defaults = {‘color’:’red’}, 变量名可以命名为属性名OR选择器名称、中划线和下划线可以相互混用 123456789$highlight-color: #efe0ce;$highlight-border: 1px solid $hightlight-color;.selected&#123; border: $highlight-border;&#125;// 编译.selected &#123; border: 1px solid #efe0ce;&#125; 文件导入.blue{@import &quot;blue-theme&quot;} 不能用sass的@import直接导入一个原始的css文件，因为sass会认为你想用css原生的@import。但是，因为sass的语法完全兼容css，所以你可以把原始的css文件改名为.scss后缀，即可直接导入了。 嵌套 痛点：css中重复写选择器是令人恼怒的、为了样式的不冲突需要一遍遍的写相同的ID 解决：sass的嵌套写法、只需写一遍、且可读性大大提高 在sass书写中会配到使用伪类元素情况:hover :after nth-child使用常规的嵌套方案会出现问题 正常的嵌套解耦是通过一个空格链接到子选择器的前面后代选择器 使用父选择器标示符&amp; 子组合选择器和同层组合选择器 123456789article&#123; ~ article&#123;border-top: 1px dashed #ccc;&#125; &gt; section &#123;background-color: #eee;&#125; dl &gt; &#123; dt&#123;color: #333;&#125; dd&#123;color: #555;&#125; &#125; nav + &amp; &#123;margin-top: 0;&#125;&#125; 属性嵌套 1234567891011nav &#123; border: 1px solid #ccc &#123; left: 1px; right: 1px; &#125;&#125;nav &#123; border: 1px solid #ccc; border-left: 1px; border-right: 1px;&#125; sass的条理性和可读性基础：变量、嵌套、导入、注释 混合器 痛点：整个网站中有几处小小的样式类似（例如一致的颜色和字体），那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。 通过@mixin example标示符定义、然后使用 @include example调用 大多数情况@extend可以满足日常的开发需求 而@include、较少使用的到e.g. 计算rem和px的装换 至于css3的前缀问题可以使用Autoprefixer插件在构建完成后自动添加 @include和@extend的区别 @include是用来调用@mixin的定义(包括) @extend(延伸) 继承选择器的样式 继承一个定义好的placeholder 相同之处：都可以給选择器添加一系列属性、而不用重复手写 不同之处： @extend会合并选择器、共享属性 @mixin每个选择器是独立存在的 修改伪元素 修改伪元素的content的属性值 12345678910// CSS代码.red::before &#123; content: attr(data-attr); color: red;&#125;// HTML代码&lt;div class="red" data-attr="red"&gt;内容内容内容内容&lt;/div&gt;// JacaScript代码$('.red').attr('data-attr', 'green'); 更改伪元素的样式1 12345678910111213// CSS代码.red::after&#123; content:"red", color: red;&#125;.green::after&#123; content:"green", color: green;&#125;// HTML代码&lt;div class="red"&gt;内容内容内容&lt;/div&gt;// jQuery代码$(".red").removeClass("red").addClass("green"); 更改伪元素的样式2 1234document.styleSheets[0].addRule('.red::before','color: green'); // 支持IE document.styleSheets[0].insertRule('.red::before &#123; color: green &#125;', 0); // 支持非IE的现代浏览器// styleSheets:返回由网页中所用到的样式表组成的数组，但是不包括直接嵌在元素里的style。 1$('&lt;style&gt;.red::before&#123;color:green&#125;&lt;/style&gt;').appendTo('head');]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css如何居中一个浮动元素]]></title>
      <url>%2F2016%2F08%2F30%2F%E6%AF%8F%E6%97%A5ES6%20-%20let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[let和var的区别 块级作用域：用let定义的变量只在定义它的块中有效 不会变量提升、为声明前使用、直接报错。 let会暂时性死区、一但快内let声明了a、全局变量a将不会起作用 let不允许在相同作用域内、重复声明同一个变量 为什么引进块级作用域？for循环的i变量控制循环、防止泄露在ES6之前 - JS没有块级作用域 12345678910111213141516// function要注意的规范// 应该避免在块级作用域内声明函数、如果确实需要、也应该写成函数表达式、而不是函数式声明// 函数式声明&#123; let a = "shen"; function f()&#123; return a; &#125;&#125;// 函数表达式&#123; let a = "yang"; let b = function()&#123; return a; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css如何居中一个浮动元素]]></title>
      <url>%2F2016%2F08%2F30%2F%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%ADdiv%EF%BC%9F%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0.html</url>
      <content type="text"><![CDATA[如何利用CSS居中一个浮动元素 居中一个浮动元素 宽度是必须的 使用相对定位 使用margin 1234567891011div&#123; position: relative;//相对于父级 left: 50%; top: 50%; float: left; margin-left: -100px; margin-top: -100px; width: 200px; height: 200px; background-color: red;&#125; 如何居中divcss中可以被继承的属性font-size、font-family、font-size、font-weight、color、text-indent、line-height、text-align、letter-spacing、word-spacing 文本相关属性 font-size、font-style、font-family、font-weight、font、 line-height、text-align、 text-indent首行文本缩进、letter-spacing单个字母间距、word-spacing以空白为分割间距 列表相关属性(li) list-style-type: decimal数字、circle空心圆、默认实心圆 list-style-position:inside放在文本以内且环绕文本 outside默认 list-style-image:使用图像来替换列表项的标记 缩写形式:list-style: decimal outside url(&#39;img/arror.gif&#39;); 颜色color 若被问到类似的问题 字体系列font-size\font-family\font-style\font-weight 字体颜色color 字体间距letter-spacing\word-spacing 列表系列list-style-image\type\position line-height\text-align\text-indent css中的选择器 常规选择器：ID\class\元素\ *通配符 伪类选择器： 动态伪类选择器:link\:visited\:active\:hover\:focus 状态伪类选择器 E:disabled{}匹配所有被禁言的表单元素 E:checked{}匹配表单中被选中的单选或复选按钮 E:enabled{}匹配被启用的元素(表单元素)checked反面 结构伪类 E:first-child选取特定元素的第一个子元素 OR last-child E:first-of-type(){} 和first-child一样、只是指定了元素类型 E:nth-child(n)选取特定元素的一个或多个子元素、n虫1开始、也可以是odd(奇数)，even(偶数)。E:nth-last-child(n) E:nth-of-type(n){}计算父元素中指定的某种类型的子元素 E:root匹配E所在文档的跟元素 E::first-line匹配元素的第一行文本、常用于文本排版 E::after E::before ::selection选中的文本背景颜色 关系选择器： A &gt; E 直系后代(children)子代选择器 A E 后代元素(find)后代选择器 E + F 同辈元素且在E后面的元素(next)相邻兄弟元素选择器 样式的优先级算法 - 优先级 内联 ID选择器 伪类选择器e.g: E:first-child{} 属性选择器e.g: input[type=&quot;text&quot;]{} 类选择器 元素选择器 通配符 !important除外]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抓包工具]]></title>
      <url>%2F2016%2F08%2F22%2F%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7.html</url>
      <content type="text"><![CDATA[抓包工具Win上的抓包 - Fiddler工具使用 Mac上的抓包 - Charles正版购买 Qi Tang’s Blog站的Charles使用心得 使用Charles、记录安装和使用 VPN 打开VPN之后、Charles将不会工作、因此撤掉VPN 设置端口并开启代理 确定工具栏下的 Proxy-&gt;Mac OS X Proxy被勾选上了 安装SSL证书 手机设置手机端和电脑链接在一个网段内，设置HTTP代理 然后打开手机浏览器，输入 http://www.charlesproxy.com/getssl/进行mac电脑charles ssl 根证书安装 安装成功之后不管是手机内部app还是浏览器浏览https 站点，都可以进行抓包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH Key到Github]]></title>
      <url>%2F2016%2F08%2F18%2F%E6%B7%BB%E5%8A%A0SSH%20Key%E5%88%B0Github.html</url>
      <content type="text"><![CDATA[添加ssh key到Github首先先确认是否已经存在公钥了( SSH Keys ) 1ls -al ~/.ssh 若存在id_rsa或id_rsa.pub。则代表已经生成过Key值、直接将SSH key添加到Github中 生成SSH 公钥1ssh-keygen -t rsa -C "注释内容，一般为邮件地址 xxx@163.com" 接着会显示以下的输出 123456789101112131415161718192021Generating public/private rsa key pair.Enter file in which to save the key (/Users/eguchi/.ssh/id_rsa): # &lt;输入Enter键&gt;Created directory '/Users/eguchi/.ssh'.Enter passphrase (empty for no passphrase): # &lt;输入验证密码&gt;Enter same passphrase again: # &lt;再输入一次相同的验证密码&gt;Your identification has been saved in /Users/eguchi/.ssh/id_rsa.Your public key has been saved in /Users/eguchi/.ssh/id_rsa.pub.The key fingerprint is:57:15:3c:ca:f2:dc:27:6d:c2:9a:88:d0:70:cf:8d:31 xxx@163.comThe key's randomart image is:+--[ RSA 2048]----+| .o. || .o || ... . || . . E.o || +So.O o . || . ..+ + = +|| . . . o = || . . o || |+-----------------+ 默认会在相应路径下~/.ssh生成id_rsa和id_rsa.pub两个文件 复制id_rsa.pub文件信息cat ~/.ssh/id_rsa.pub。将这些信息复制到Github的Add SSH key页面。 输出实例 123456ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDkkJvxyDVh9a+zH1f7ZQq/JEI79dVjDSG4RzttQwfK+sgWEr0aAgfnxdxQeDKxIxqI1SwyTY8oCcWzvpORuPqwbc7UWWPcCvbQ3jlEdN5jvwKM82hincEWwI3wzcnVg2Mn8dH86b5m6REDzwRgozQ3lqrgwGVlTvkHDFs6H0b/1PSrMXGppOP/QXGEVhZ6Hy4m3b1wMjjrbYwmWIeYklgoGHyrldhAaDYc33y7aUcRyFyq5DubtsLn2oj4K+1q36iviCHxCOri0FDmn2dzylRCI4S+A2/P7Y7rVfdT+8OWYKCBUs8lfjujghEtejqQmj9ikyGTEAW1zQCN7hVwYdjL xxx@163.com 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key: Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。 不同的操作系统，均有一些命令，直接将SSH key从文件拷贝到粘贴板中，如下：mac 12pbcopy &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard windows 12clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard linux 12345sudo apt-get install xclip# Downloads and installs xclip. If you don&apos;t have `apt-get`, you might need to use another installer (like `yum`)xclip -sel clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard 错误处理1ssh -T git@github.com 超时报错 1ssh: connect to host github.com port 22: Operation timed out 让SSH走443端口解决方案 编辑~/.ssh/config文件(若没有、则创建一个)touch config vim config 123456789101112131415161718192021222324Host github.comUser ntscshen@163.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host gi.coding.netUser ntscshen@163.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host，SSH 连接名HostName，如上所示，可以是通配符，可以是 IP，也可以是域名等User，登录的用户名IdentifyFile， version 1 协议下默认是 ~/.ssh/identify， version 2 协议下，默认是依次匹配：~/.ssh/id_dsa，~/.ssh/id_ecdsa，~/.ssh/id_rsa， 还有 version 2 兼容模式。LocalForward 端口的内部跳转Port，端口设置，默认 SSH 的端口是 22 // 公司封github 22端口Protocal，协议版本号，1 或者 2 :wq 参数说明 ssh-keygen 用于为 ssh(1)生成、管理和转换认证密钥，包括 RSA 和 DSA 两种密钥。 密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。 -t type - 指定要创建的密钥类型。可以使用：”rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2) -C comment - 提供一个新注释]]></content>
    </entry>

    
  
  
</search>
