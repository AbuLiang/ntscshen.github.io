<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[设计模式-策略模式]]></title>
      <url>http://ntscshen.com/2017/02/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F(2).html</url>
      <content type="html"><![CDATA[<blockquote>
<p>策略模式( <strong>Strategy</strong> )：将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化</p>
<p>策略模式( <strong>Strategy</strong> )：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换</p>
</blockquote>
<h1 id="使用策略模式计算奖金"><a href="#使用策略模式计算奖金" class="headerlink" title="使用策略模式计算奖金"></a>使用策略模式计算奖金</h1><blockquote>
<p>年终奖是根据员工的工资基数和年底绩效来发放的</p>
<p>绩效S的人有4倍工资、绩效A的人有3倍工资，绩效B的人有2倍工资</p>
</blockquote>
<h2 id="最初的代码实现-1"><a href="#最初的代码实现-1" class="headerlink" title="最初的代码实现(1)"></a>最初的代码实现(1)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// calculate:计算，bonus:奖金，salary:薪水，performance:工作情况</span></div><div class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params">performanceLevel, salary</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (performanceLevel === <span class="string">'S'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (performanceLevel === <span class="string">'A'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> salary * <span class="number">3</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (performanceLevel === <span class="string">'B'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> salary * <span class="number">2</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">calculateBonus(<span class="string">'S'</span>,<span class="number">25000</span>);</div><div class="line">calculateBonus(<span class="string">'B'</span>,<span class="number">9000</span>);</div></pre></td></tr></table></figure>
<p>非常简单的代码，但是存在的问题也显而易见。</p>
<ol>
<li><code>calculateBonus</code> 函数比较庞大，包含了很多if-else语句，这些语 <strong>句需要覆盖所有的逻辑分支</strong> </li>
<li><code>calculateBonus</code> 函数缺乏弹性，如果增加了一种新的绩效等级C，或者想把绩效S的奖金修改为5，那我们必须深入 <code>calculateBonus</code> 函数的内部实现，这违反 <strong>开放-封闭</strong> 原则</li>
<li>算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢？我们的选择只有复制和粘贴</li>
</ol>
<h2 id="使用组合函数重构代码-2"><a href="#使用组合函数重构代码-2" class="headerlink" title="使用组合函数重构代码(2)"></a>使用组合函数重构代码(2)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> performanceS = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> salary * <span class="number">4</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> performanceA = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> performanceB = <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params">performanceLevel, salary</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (performanceLevel === <span class="string">'S'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> performanceS(salary);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (performanceLevel === <span class="string">'A'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> performanceS(salary);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (performanceLevel === <span class="string">'B'</span>) &#123;</div><div class="line">        <span class="keyword">return</span> performanceS(salary);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">calculateBonus(<span class="string">'A'</span>, <span class="number">18000</span>);</div></pre></td></tr></table></figure>
<p>组容易想到重构代码的办法就是：使用组合函数来重构代码</p>
<ol>
<li>把各种算法封装到一个个的小函数里，这些小函数有这良好的命名规范、一目了然地知道它对应着那种算法，他们可以被复用在程序的其他地方</li>
</ol>
<p>程序确实得到了一些非常有限的改善，但是依然没有解决最重要的问题</p>
<ul>
<li><code>calculateBonus</code> 函数有可能越来越大</li>
<li>协同变化的时候缺乏弹性</li>
</ul>
<p><strong>将不变的部分</strong> 和 <strong>变化的部分</strong> 隔开是每个设计模式的主题</p>
<p>策略模式的目的就是将算法的使用与算法的实现分离开来</p>
<p>一个基于策略模式的程序至少由两部分组成。</p>
<ol>
<li>一组策略类，策略类封装了具体的算法，并负责具体的计算过程</li>
<li>环境类Context，Context接受客户的请求，随后把请求委托給摸一个策略类。要做到这点，说明Context中药维持对某个策略对象的引用</li>
</ol>
<h2 id="策略模式重构代码-3-1"><a href="#策略模式重构代码-3-1" class="headerlink" title="策略模式重构代码(3-1)"></a>策略模式重构代码(3-1)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JavaScript版本的策略模式</span></div><div class="line"><span class="comment">// 策略模式指的是定义一系列的算法，并且把他们封装起来。</span></div><div class="line"><span class="keyword">var</span> strategies = &#123;</div><div class="line">    <span class="string">"S"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> salary * <span class="number">4</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"A"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> salary * <span class="number">3</span>;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"B"</span>: <span class="function"><span class="keyword">function</span>(<span class="params">salary</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> salary * <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> calculateBonus = <span class="function"><span class="keyword">function</span>(<span class="params">level, salary</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> strategies[level](salary);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(calculateBonus(<span class="string">'S'</span>, <span class="number">30000</span>));</div><div class="line"><span class="built_in">console</span>.log(calculateBonus(<span class="string">'A'</span>, <span class="number">20000</span>));</div></pre></td></tr></table></figure>
<blockquote>
<p>通过使用策略模式重构代码，<strong>消除了原程序中大片的条件分支语句</strong>。</p>
<p>所有跟计算奖金有关的逻辑不再放在Context中，而是分布在各个策略对象中。Context并没有计算过奖金的能力，而是把这个职责委托給了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。</p>
<p>当我们对这些策略对象发出”计算奖金”的请求时，它们会放回各自不同的计算结果，这正是对象多态性的体现，也是”它们可以相互替换”的目的，替换Context中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果</p>
</blockquote>
<h1 id="策略模式-表单校验"><a href="#策略模式-表单校验" class="headerlink" title="策略模式 - 表单校验"></a>策略模式 - 表单校验</h1><blockquote>
<p>将用户输入的数据交給后台之前，常常要做一些前端力所能及的校验工作，比如注册的时候需要校验是否填写用户名，密码的长度是否符合规定。。</p>
<p><strong>这样是为了避免因为提交不合法数据而带来的不必要的网络开销。</strong></p>
</blockquote>
<p><strong>在点击提交按钮之前，有几条校验的逻辑</strong></p>
<ol>
<li>姓名、手机号、验证码不能为空</li>
<li>手机号、验证码 非错误</li>
<li>手机号必须符合格式</li>
<li>输入框需过滤特殊字符 - 防SQL注入</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一步：把校验逻辑都封装成 '策略对象'</span></div><div class="line"><span class="keyword">var</span> strategies = &#123;</div><div class="line">    <span class="attr">isNonEmpty</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value, errorMsg</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (value === <span class="string">''</span>) &#123;</div><div class="line">            <span class="keyword">return</span> errorMsg;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">minLength</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value, length, errorMsg</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (value.length &lt; length) &#123;</div><div class="line">            <span class="keyword">return</span> errorMsg;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">isMobile</span>: <span class="function"><span class="keyword">function</span>(<span class="params">value, errorMsg</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="regexp">/^1[3|5|8][0-9]&#123;9&#125;9$/</span>.test(value)) &#123;</div><div class="line">            <span class="keyword">return</span> errorMsg;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式 - 单例模式(1)]]></title>
      <url>http://ntscshen.com/2017/02/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(1).html</url>
      <content type="html"><![CDATA[<blockquote>
<p>单例模式( <strong>Singleton</strong> )：确保只有一个实例，并提供全局访问</p>
</blockquote>
<p>在 <strong>JavaScript</strong> 开发中，我们经常会把全局变量当做单例来使用</p>
<p><code>var a = {};</code></p>
<h1 id="命名空间-namespace-的管理"><a href="#命名空间-namespace-的管理" class="headerlink" title="命名空间( namespace )的管理"></a>命名空间( namespace )的管理</h1><blockquote>
<p>命名空间：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所有不同的人定义的变量使用的单词名称很有可能重复，此时就需要使用命名空间来约束每个人定义的变量来解决这类问题。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> BusinessGoInit = &#123;</div><div class="line">    <span class="attr">getServerTime</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 获取服务器时间戳</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">isUserVip</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 是否为会员</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">toShortUrl</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 短链接</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="模块分明"><a href="#模块分明" class="headerlink" title="模块分明"></a>模块分明</h1><blockquote>
<p>通过单例模式来管理代码库的各个模块</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> A = &#123;</div><div class="line">    <span class="attr">Util</span>: &#123;</div><div class="line">        <span class="attr">util_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">util_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">Tool</span>: &#123;</div><div class="line">        <span class="attr">tool_method1</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">tool_method2</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">Ajax</span>: &#123;</div><div class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">post</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">others</span>: &#123;</div><div class="line">        <span class="attr">xxx</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">        <span class="attr">yyy</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="管理静态变量"><a href="#管理静态变量" class="headerlink" title="管理静态变量"></a>管理静态变量</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Conf = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 私有变量</span></div><div class="line">    <span class="keyword">var</span> config = &#123;</div><div class="line">            <span class="attr">MAX_NUM</span>: <span class="number">100</span>,</div><div class="line">            <span class="attr">MIN_NUM</span>: <span class="number">1</span>,</div><div class="line">            <span class="attr">COUNT</span>: <span class="number">1000</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 返回取值器对象</span></div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="comment">// 通过取值器方法访问静态变量</span></div><div class="line">        get: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> config[name] ? config[name] : <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="keyword">var</span> count = Conf.get(<span class="string">'COUNT'</span>);</div><div class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1000</span></div><div class="line"><span class="comment">// 静态变量只能访问，不能修改。并且无创建后就能使用</span></div></pre></td></tr></table></figure>
<h1 id="惰性单例"><a href="#惰性单例" class="headerlink" title="惰性单例"></a>惰性单例</h1><blockquote>
<p>惰性单例：在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用。</p>
</blockquote>
<p>案例：登陆窗、在一个项目里登陆窗总是唯一的，不可能同时存在两个登陆窗口的情况 <strong>( 两种解决方案 )</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 解决方案一：</span></div><div class="line"><span class="comment">// 1、在页面加载完成的时候便创建好这个div弹窗</span></div><div class="line"><span class="comment">// 2、弹窗一开始肯定是隐藏的姿态</span></div><div class="line"><span class="comment">// 3、用户点击登陆按钮，显示弹窗</span></div><div class="line"><span class="keyword">var</span> loginLayer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">  oDiv.innerHTML = <span class="string">'我是登录框'</span>;</div><div class="line">  oDiv.style.display = <span class="string">'none'</span>;</div><div class="line">  <span class="built_in">document</span>.body.appendChild(oDiv);</div><div class="line">  <span class="keyword">return</span> oDiv;</div><div class="line">&#125;)();</div><div class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  loginLayer.style.display = <span class="string">'block'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这种方式有一个问题，也许我们进入当前项目根本不需要登陆操作</span></div><div class="line"><span class="comment">// 应为登陆窗口总是在一开始就被创建好，那么就会白白浪费掉一些DOM节点</span></div><div class="line"><span class="comment">// 解决方案一：改进1</span></div><div class="line"><span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">  oDiv.innerHTML = <span class="string">'我是登录框'</span>;</div><div class="line">  oDiv.style.display = <span class="string">'none'</span>;</div><div class="line">  <span class="built_in">document</span>.body.appendChild(oDiv);</div><div class="line">  <span class="keyword">return</span> oDiv;</div><div class="line">&#125;</div><div class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> loginLayer = createLoginLayer();</div><div class="line">  loginLayer.style.display = <span class="string">'block'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 改进方案虽然实现了惰性的目的，但是失去了单例的效果。</span></div><div class="line"><span class="comment">// 当我们每次点击登陆按钮的时候，都会创建一个新的登录弹窗div</span></div><div class="line"><span class="comment">// 虽然我们可以在点击弹出上的关闭按钮时，把这个弹出从页面中删除</span></div><div class="line"><span class="comment">// 但这样频繁地创建和删除节点明显是不合理的，也是不必要的</span></div><div class="line"><span class="comment">// 解决方案一：改进2</span></div><div class="line"><span class="comment">// 可以使用一个变量来判断是否已经创建过登录弹出了</span></div><div class="line"><span class="keyword">var</span> createLoginLayer = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> div = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">if</span>(!div)&#123;</div><div class="line">      div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">      div.innerHTML = <span class="string">'我是登录弹出'</span>;</div><div class="line">      div.style.display = <span class="string">'none'</span>;</div><div class="line">      <span class="built_in">document</span>.body.appendChild(div);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> div;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> loginLayer = createLoginLayer();</div><div class="line">  loginLayer.style.display = <span class="string">'block'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这样写就完成了一个可用的惰性单例，但还有一些问题</span></div><div class="line"><span class="comment">// 创建对象和管理单例都放在createLoginLayer对象内部</span></div><div class="line"><span class="comment">// 复用性 - 若下次创建iframe或者script，就必须如法炮制</span></div><div class="line"><span class="comment">// 把createLoginLayer函数几乎照抄一遍</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 解决方案二：按需加载</span></div><div class="line"><span class="comment">// 我们把如何管理单例的逻辑从原来的代码中抽离出来</span></div><div class="line"><span class="comment">// 封装在getSingle函数内部，创建对象的方法fn被当做参数动态的传入</span></div><div class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> result;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// return result || (result = fn());</span></div><div class="line">    <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> createLoginLayer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</div><div class="line">  oDiv.innerHTML = <span class="string">'我是登录框'</span>;</div><div class="line">  oDiv.style.display = <span class="string">'none'</span>;</div><div class="line">  <span class="built_in">document</span>.body.appendChild(oDiv);</div><div class="line">  <span class="keyword">return</span> oDiv;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> createSingleLoginLayer = getSingle(createLoginLayer);</div><div class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> loginLayer = createSingleLoginLayer();</div><div class="line">  loginLayer.style.display = <span class="string">'block'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 我们把创建实例对象的职责 和 管理单例的职责分别放置在两个方法里面</span></div><div class="line"><span class="comment">// 两个方法可以独立变化而互不影响，当他们链接在一起，就完成了创建唯一实例对象的功能</span></div><div class="line"><span class="comment">// 再试试创建唯一的iframe用于动态加载第三方页面</span></div><div class="line"><span class="keyword">var</span> createSingleIframe = getSingle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</div><div class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</div><div class="line">  <span class="keyword">return</span> iframe;</div><div class="line">&#125;);</div><div class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> loginLayer = createSingleIframe();</div><div class="line">  loginLayer.src = <span class="string">'http://hao123.com'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[this深入理解]]></title>
      <url>http://ntscshen.com/2016/12/31/this%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p><code>回想起这6个月的工作经历、业务做了不少，熟练度直线上升。然而归纳却寥寥无几，这让我再次抓起了我当初简历博客的初衷，不花时间精力去总结，平时业务上用到的零散的知识就很难形成体系。善于归纳总结：如果不善于归纳总结，每次做完项目就结束了，进入循环，那么永远是士兵，不要总是讲一些口号，喊口号的人可以当主持人，但是不能当将军。不归纳就不能前进，不前进就永远在原地踏步。认识一步步前进的，只要一小步一小步地前进，过几年当你汇总总结时，就会发现你前进了一大步。</code></p>
<h1 id="This、call、apply"><a href="#This、call、apply" class="headerlink" title="This、call、apply"></a>This、call、apply</h1><blockquote>
<p><strong>This：</strong><br>JavaScript的this总是指向一个对象。</p>
<p>而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。</p>
<p><code>this</code> 的绑定和函数声明的位置没有任何关系，只取决于函数的<strong>调用方式</strong>。</p>
<p><code>this</code> 实际上是在函数被调用时发生的绑定，它指向什么完全取决于<strong>函数在哪里被调用</strong></p>
<p>在理解 <code>this</code> 是什么❓首先必须要找到”<strong>调用位置</strong>“，然后判断符合那种规则。</p>
<p>当一个函数被调用时，会创建一个”执行上下文环境”：</p>
<ol>
<li>包含函数在哪里被调用 <strong>( 调用栈 )</strong> 。</li>
<li>函数调用方法。</li>
<li>传入的参数等信息。</li>
<li><code>this</code> 就是记录的其中一个属性，会在函数执行的过程中用到。</li>
</ol>
</blockquote>
<h2 id="This指向大致可以分为如下四类："><a href="#This指向大致可以分为如下四类：" class="headerlink" title="This指向大致可以分为如下四类："></a>This指向大致可以分为如下四类：</h2><ol>
<li>作为对象的方法调用。</li>
<li>作为普通函数调用。</li>
<li>构造器调用</li>
<li><code>Function.prototype.call</code> 和 <code>Function.prototype.apply</code> 调用</li>
</ol>
<h3 id="1、作为对象的方法调用"><a href="#1、作为对象的方法调用" class="headerlink" title="1、作为对象的方法调用"></a>1、作为对象的方法调用</h3><blockquote>
<p>当函数作为对象的方法被调用时, <code>this</code> 指向该对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当函数作为对象的方法被调用时、this指向该对象</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">a</span>:<span class="number">1</span>,</div><div class="line">  <span class="attr">getA</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="keyword">this</span> === obj);<span class="comment">//true</span></div><div class="line">    alert(<span class="keyword">this</span>.a);<span class="comment">//1</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-1、隐式绑定"><a href="#1-1、隐式绑定" class="headerlink" title="1-1、隐式绑定"></a>1-1、隐式绑定</h4><blockquote>
<p>另一条需要考虑的规则是：</p>
<p>调用位置是 <strong>否有上下文 — “对象”</strong> ，或者说</p>
<p>是否被某个对象拥有( 包含 )</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">	console.log(this.a);</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">  	a:2,</div><div class="line">  	foo:foo</div><div class="line">&#125;</div><div class="line">obj.foo();</div><div class="line">## 1：无论是直接在obj中定义、还是先定义再添加为引用属性，这个函数严格来说都不属于obj对象。</div><div class="line">## 2：然而，调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象"拥有"或者"包含"了它。</div><div class="line">## 3：无论我们如何称呼这个模式，当foo()被调用时，它的落脚点确实指向obj对象。当函数引用有上下文对象时，"隐式绑定"规则会把函数调用中的"this"绑定到这个上下文对象。因为调用foo()时this被绑定到obj，所以this.a和obj.a是一样的</div><div class="line">## 4：对象属性引用链中，只有最后一层( 最顶层 )会影响到调用位置</div></pre></td></tr></table></figure>
<h3 id="1-2、隐式绑定丢失"><a href="#1-2、隐式绑定丢失" class="headerlink" title="1-2、隐式绑定丢失"></a>1-2、隐式绑定丢失</h3><blockquote>
<p>最常见的隐式绑定问题：</p>
<p>被”隐式绑定”的函数会丢失绑定对象，也就是说它会应用”默认绑定”，从而把this绑定到全局对象或者”undefined”上，取决于是否是”严格模式”</p>
<p>解决办法：使用”显示绑定”的方案 <code>call(...)和apply(…)</code> 的”硬绑定”模式</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 丢失案例一：堆内存地址的引用</div><div class="line">function foo()&#123;</div><div class="line">  console.log(this.a);</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">  a:2,</div><div class="line">  foo:foo</div><div class="line">&#125;</div><div class="line">var bar = obj.foo;</div><div class="line">var a = "oops,global";</div><div class="line">bar();// oops,global</div><div class="line">## 虽然bar是obj.foo的一个引用。</div><div class="line">## 但是实际上，它引用的是foo函数本身,是foo函数在堆内存空间的地址(复制的是指针的指向)</div><div class="line">## 本质上：bar() == foo();</div><div class="line">## 因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</div><div class="line"></div><div class="line">// 丢失案例二：非常常见并且非常出乎意料的情况(参数传递)</div><div class="line">function foo()&#123;</div><div class="line">  	console.log(this.a);</div><div class="line">&#125;</div><div class="line">function doFoo(fn)&#123;</div><div class="line">  	fn();</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">  	a:2,</div><div class="line">  	foo:foo</div><div class="line">&#125;</div><div class="line">var a = "oops,global";</div><div class="line">doFoo(obj.foo);</div><div class="line">## 参数传递其实"就是"一种隐式赋值，因此我们传入函数时也会被隐式赋值。</div></pre></td></tr></table></figure>
<h4 id="引用类型参数传递问题"><a href="#引用类型参数传递问题" class="headerlink" title="引用类型参数传递问题"></a>引用类型参数传递问题</h4><blockquote>
<p>引用类型：引用类型传递的是指针的方向</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">  	obj.name = <span class="string">'aaa'</span>;</div><div class="line">  	<span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">'bbb'</span>;</div><div class="line"><span class="keyword">var</span> newPerson = setName(person);</div><div class="line"><span class="built_in">console</span>.log(person.name + <span class="string">' || '</span> + newPerson.name);</div></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/zareb/p/5699571.html" target="_blank" rel="external">http://www.cnblogs.com/zareb/p/5699571.html</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">	obj.name = <span class="string">'aaa'</span>;</div><div class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); <span class="comment">// 如果是按引用传递的,此处传参进来obj应该被重新引用新的内存单元</span></div><div class="line">	obj.name = <span class="string">'ccc'</span>;</div><div class="line">	<span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	person.name = <span class="string">'bbb'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> newPerson = setName(person);</div><div class="line"><span class="built_in">console</span>.log(person.name);</div><div class="line"><span class="built_in">console</span>.log(newPerson.name);</div></pre></td></tr></table></figure>
<h3 id="2、作为普通函数调用-this-默认绑定"><a href="#2、作为普通函数调用-this-默认绑定" class="headerlink" title="2、作为普通函数调用 ( this - 默认绑定 )"></a>2、作为普通函数调用 ( this - 默认绑定 )</h3><blockquote>
<p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 <code>this</code> 总是指向全局对象。在浏览器的 <code>JavaScript</code> 里，这个全局对象是 <code>window</code> 对象。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 使用普通函数时、其内的this总是指向window</div><div class="line">// 在代码中，getName()是直接使用不带任何修饰的函数引用进行调用的。因此只能使用"默认绑定"，无法应用其他规则。</div><div class="line">// 如果是严格模式( strict mode ),那么全局对象将无法使用默认规则，因此this会绑定到"undefined"上</div><div class="line">// 案例一：</div><div class="line">window.name = 'globalName';</div><div class="line">var getName = function()&#123;</div><div class="line">  return this.name;</div><div class="line">&#125;</div><div class="line">console.log(getName());//globalName</div><div class="line">// 案例二：引用getName在堆内存中的地址</div><div class="line">window.name = 'globalName';</div><div class="line">var myObject = &#123;</div><div class="line">  name:'ntscshen',</div><div class="line">  getName:function()&#123;</div><div class="line">    return this.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var myName = myObject.getName;</div><div class="line">console.log(myName());</div><div class="line">// 案例三：在事件函数内部、有一个局部的方法。此方法被调用时，方法内部的this指向了window</div><div class="line">document.getElementById('div1').onclick = function()&#123;</div><div class="line">  console.log(this.id);// 'div1'</div><div class="line">  //var _this = this;// 简单的解决方案</div><div class="line">  var callBack = function()&#123;</div><div class="line">    //console.log(_this.id);// 'div1'</div><div class="line">    console.log(this.id);// 'window'</div><div class="line">  &#125;</div><div class="line">  callBack();</div><div class="line">&#125;</div><div class="line">## 没当你想要把this和"词法"作用域的查找混合使用时，一定要提醒自己，这是无法实现的。</div></pre></td></tr></table></figure>
<h3 id="3、构造器调用"><a href="#3、构造器调用" class="headerlink" title="3、构造器调用"></a>3、构造器调用</h3><h4 id="4、-Function-prototype-call-和-Function-prototype-apply"><a href="#4、-Function-prototype-call-和-Function-prototype-apply" class="headerlink" title="4、 Function.prototype.call 和 Function.prototype.apply"></a>4、 <code>Function.prototype.call</code> 和 <code>Function.prototype.apply</code></h4><h4 id="4-1：硬绑定"><a href="#4-1：硬绑定" class="headerlink" title="4-1：硬绑定"></a>4-1：硬绑定</h4><blockquote>
<p>硬绑定的典型应用场景就是：<strong>创建一个包裹函数，传入所有的参数并返回接收到的所有值。</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 案例一：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">2</span>&#125;</div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	foo.call(obj);</div><div class="line">&#125;;</div><div class="line">bar();</div><div class="line">setTimeout(bar,<span class="number">100</span>);</div><div class="line">bar.call(<span class="built_in">window</span>);</div><div class="line"><span class="comment">// 我们首先创建了函数bar()，并在它的内部手动调用了foo.call(obj),因此强制把foo的this绑定到了obj。无论之后如何调用函数bar，它总会手动在obj上调用foo。这种绑定是一种显示的强制绑定，因此称之为"硬绑定"</span></div><div class="line"><span class="comment">// 案例二：</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	<span class="built_in">console</span>.log(<span class="keyword">this</span>.a,something);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.a + something;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>)</span>&#123;</div><div class="line">  	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      	<span class="keyword">return</span> fn.apply(obj, <span class="built_in">arguments</span>);</div><div class="line">  	&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">2</span>&#125;;</div><div class="line"><span class="keyword">var</span> b = bar(<span class="number">3</span>);</div><div class="line"><span class="built_in">console</span>.log(b);</div><div class="line"><span class="comment">// 由于硬绑定是一种非常常用的模式，所以在ES5中提供了内置的方法Function.prototype.bind,它的用法如下</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[手机号码中间部分替换成星号]]></title>
      <url>http://ntscshen.com/2016/12/07/%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E4%B8%AD%E9%97%B4%E9%83%A8%E5%88%86%E6%9B%BF%E6%8D%A2%E6%88%90%E6%98%9F%E5%8F%B7.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>手机号中间4未数字使用星号替换</p>
</blockquote>
<ol>
<li>字符串截取</li>
<li>正则</li>
</ol>
<h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 字符串截取 + 拼接</span></div><div class="line"><span class="string">'18500009973'</span>.substr(<span class="number">0</span>, <span class="number">3</span>) + <span class="string">'****'</span> + <span class="string">'18500009973'</span>.substr(<span class="number">7</span>, <span class="number">11</span>);</div><div class="line"><span class="comment">// 优化:确保输入的是字符串类型</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatPhone</span>(<span class="params">phone</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> phone == <span class="string">'number'</span>)&#123;</div><div class="line">	phone = phone.toString();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> phone.substr(<span class="number">0</span>, <span class="number">3</span>) + <span class="string">'****'</span> + phone.substr(<span class="number">7</span>, <span class="number">11</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 什么❓您不知道toString()是干什么的❓请看最底部</span></div></pre></td></tr></table></figure>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatPhone</span>(<span class="params">phone</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> phone == <span class="string">'number'</span>)&#123;</div><div class="line">        phone = phone.toString();</div><div class="line">    &#125;</div><div class="line">	<span class="keyword">return</span> phone.replace(<span class="regexp">/(\d&#123;3&#125;)\d&#123;4&#125;(\d&#123;4&#125;)/</span>, <span class="string">'$1****$2'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 匹配前面三个数字，讲匹配的值給$1,然后匹配中间4个数字，再匹配最后4个数字給$2</span></div><div class="line"><span class="comment">// 什么❓您不会正则❓好吧！我也只会一点点</span></div></pre></td></tr></table></figure>
<h4 id="JavaScript-toString-函数详解"><a href="#JavaScript-toString-函数详解" class="headerlink" title="JavaScript toString()函数详解"></a>JavaScript toString()函数详解</h4><p><code>toString()</code> 函数用于将当前对象以字符串的形式放回。</p>
<p>由于该方法属于 <code>Object</code> 对象，因此所有的对象都”<strong>继承</strong>“了 <code>Object</code> 的对象实例，所有的的实例对象都可以使用该方法、所有主流浏览器均支持该函数</p>
<blockquote>
<p>JavaScript的许多内置对象都重写了该函数、以实现更适合自身的功能需求</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number</td>
<td style="text-align:left">返回数值的字符串表示。(可以指定转换的 <strong>进制</strong> ) <a href="http://www.365mini.com/page/javascript-number-tostring.htm" target="_blank" rel="external">Number.toString详细说明地址</a></td>
</tr>
<tr>
<td>Boolean</td>
<td style="text-align:left">如果布尔值是true，则返回”true”,否则放回”false”</td>
</tr>
<tr>
<td>Array</td>
<td style="text-align:left">将Array的每个元素转换为字符串，并将它们以此连接起来，两个元素之间用英文逗号作为分隔符进行拼接</td>
</tr>
<tr>
<td>Date</td>
<td style="text-align:left">返回日期的文本表示</td>
</tr>
<tr>
<td>Error</td>
<td style="text-align:left">返回一个包含相关错误信息的字符串。</td>
</tr>
<tr>
<td>Object(默认)</td>
<td style="text-align:left">返回”[object ObjectName]”，其中 ObjectName 是对象类型的名称。</td>
</tr>
<tr>
<td>Function</td>
<td style="text-align:left">返回如下格式的字符串，其中 functionname 是一个函数的名称，此函数的 toString 方法被调用： “function functionname() { [native code] }”</td>
</tr>
</tbody>
</table>
<p><strong>实例:console</strong> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组</span></div><div class="line"><span class="keyword">var</span> array = [<span class="string">"ntscshen"</span>,<span class="literal">true</span>,<span class="string">"哈哈"</span>,<span class="number">99</span>];array</div><div class="line">[<span class="string">"ntscshen"</span>, <span class="literal">true</span>, <span class="string">"哈哈"</span>, <span class="number">99</span>]</div><div class="line">array.toString()</div><div class="line"><span class="string">"ntscshen,true,哈哈,99"</span></div><div class="line"><span class="comment">// 布尔</span></div><div class="line"><span class="keyword">var</span> bool = <span class="literal">true</span>;bool</div><div class="line"><span class="literal">true</span></div><div class="line">bool.toString()</div><div class="line"><span class="string">"true"</span></div><div class="line"><span class="comment">// 日期</span></div><div class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>;date</div><div class="line">Wed Dec <span class="number">07</span> <span class="number">2016</span> <span class="number">14</span>:<span class="number">44</span>:<span class="number">42</span> GMT+<span class="number">0800</span> (CST)</div><div class="line">date.toString()</div><div class="line"><span class="string">"Wed Dec 07 2016 14:44:42 GMT+0800 (CST)"</span></div><div class="line"><span class="comment">// 数字</span></div><div class="line"><span class="keyword">var</span> num = <span class="number">12</span>;</div><div class="line"><span class="built_in">document</span>.writeIn(num.toString());</div><div class="line"><span class="comment">// 什么❓您不知道writeIn❓那您知道write吗❓知道它们之间的区别吗❓知道如何在console打印内容吗❓知道打印的几种方式吗❓</span></div></pre></td></tr></table></figure>
<h4 id="write和writeIn"><a href="#write和writeIn" class="headerlink" title="write和writeIn"></a>write和writeIn</h4><ol>
<li><code>document.write(&#39;hello word&#39;)</code> 方法可向文档写入 HTML 表达式或 JavaScript 代码。 <strong>主要用于简单的打印内容到页面上</strong></li>
<li><code>writeIn()</code> 区别于 <code>write()</code> 的地方就是、 <code>writeIn()</code> 在末尾加了一个<strong>空格</strong> </li>
</ol>
<h4 id="console"><a href="#console" class="headerlink" title="console"></a>console</h4><ul>
<li><code>console.log()</code> 向web控制台输出一条消息 <strong>(输出普通信息)</strong></li>
<li><code>console.dir()</code> 向web控制台打印出该对象的所有属性和属性值，这个方法是我经常使用的 不知道比for in方便了多少</li>
<li><code>console.debug()</code>  console.log方法的别称，使用方法可以参考<strong>Console.log()</strong></li>
<li><code>console.warn()</code>  <strong>输出警告信息</strong></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[webPlayer使用方法总结]]></title>
      <url>http://ntscshen.com/2016/12/02/webPlayer%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<p>[TOC]</p>
<h1 id="webPlayer-使用方法的一些总结"><a href="#webPlayer-使用方法的一些总结" class="headerlink" title="webPlayer 使用方法的一些总结"></a>webPlayer 使用方法的一些总结</h1><blockquote>
<p>( 建议先仔细阅读WebPlayerSDK点播.pdf和 WebPlayerSDK直播.pdf )</p>
</blockquote>
<h3 id="点播播放器相关"><a href="#点播播放器相关" class="headerlink" title="点播播放器相关"></a>点播播放器相关</h3><ol>
<li><p>文档中给出的 <code>playId()</code> 方法在页面只有一个点播播放器的时候可以正常使用，但当页面中有直播播放器时再次调用点播播放器的 <code>playId()</code> 方法就会失效，页面不会报错代码也会执行，只是执行完毕后没有出现预期的效果。初步猜测是因为其他播放器对这个功能造成了影响。解决方法是，重新创建一个播放器覆盖原有播放器。</p>
</li>
<li><p>当点播播放器中的视频是仅会员可看时，未登录用户点击此视频时播放器内部会提示用户登陆，此时要想实现登陆操作需要在点播播放器的页面接口集合 <code>( interface对象 )</code> 中传入 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openLoginDialog :<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	verifyUserloginStatus();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>当点播播放器中的视频是仅会员可看时，已登陆的非会员用户点击此视频时，播放器内部会提示用户开通会员，pc页面点击此按钮可以正常跳转到支付页面；m站页面点击此按钮无效，需要用事件委托的形式给开通会员按钮绑定跳转到支付页面的事件；</p>
</li>
<li><p>PC页面中当点播播放器中的视频是仅会员可看时，用户中途登陆是会员的账户时播放器不会刷新（有的仅会员可看视频可以免费看前6分钟，所以存在中途登陆的情况），会依然提示他购买会员。调用播放器的 <code>loginStateChange()</code> 方法并未能解决问题，解决办法是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//监听登录状态 切换时触发</span></div><div class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    LEPass.onStatusChange(<span class="function"><span class="keyword">function</span> (<span class="params">type, userInfo</span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (type == <span class="string">"signIn"</span> ) &#123;</div><div class="line">            ($(<span class="string">".na-drama-list"</span>).find(<span class="string">".playing"</span>).find(<span class="string">"a"</span>).data(<span class="string">"pid"</span>)) &#123;</div><div class="line">                dianboPlayer($(<span class="string">".na-drama-list"</span>).find(<span class="string">".playing"</span>).find(<span class="string">"a"</span>).data(<span class="string">"pid"</span>));</div><div class="line">          &#125; </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>（找到当前正在播放视频的id，利用此id重新创建播放器或者将id传入到 <code>playId()</code> 方法中，具体怎么操作需要看当前的代码结构）；m站页面没有此问题，因为只要登陆状态发生改变m站页面会自动强制刷新。</p>
</li>
<li><p>关于点播播放器续播的问题可以调用播放器的onPlayerVideoComplete事件回调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">onPlayerVideoComplete: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;   </div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="attr">status</span>: <span class="string">'playerContinue'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="直播播放器相关"><a href="#直播播放器相关" class="headerlink" title="直播播放器相关"></a>直播播放器相关</h3><p>直播分为“直播中”、“未开始”、“已结束”三种状态，其中要注意已结束的直播视频（也就是“回看”视频），从后台取出来的回看视频数据一般会带有一个名为 <code>recordingId</code> 的参数，但是有的原本正在直播中视频在刚刚结束的时候虽然已经变成了回看视频，但是并未带有 <code>recordingId</code> 参数。所以，对于回看视频：</p>
<ol>
<li>如果取到recordingId参数就将recordingId传入到点播播放器；</li>
<li>如果取不到recordingId参数就将原本的视频id传入直播播放器。</li>
</ol>
<h3 id="一些共同的问题总结"><a href="#一些共同的问题总结" class="headerlink" title="一些共同的问题总结"></a>一些共同的问题总结</h3><ol>
<li>关于播放器黑边，如果视频的比例全部一样，那么只要保证播放器盒子的宽高比和视频的一致就没有黑边了；如果视频的比例不一致，请尽可能将播放器的宽高调到一个合适的比例以保证黑边在所有视频中都尽可能小。</li>
<li>目前已知直播播放器会影响到点播播放器的 <code>playId()</code> 方法，由于本次项目经验有限，关于播放器之间的相互影响以及其他经验还需要屏幕外的你在未来的项目中进行总结。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vue新手(1)]]></title>
      <url>http://ntscshen.com/2016/11/29/vue%E6%96%B0%E6%89%8B-1.html</url>
      <content type="html"><![CDATA[<p>Vue一个mvvm框架、比较容易上手、小巧( 适合：移动项目 )</p>
<p>HTML代码配合Json、在new一个vue实例</p>
<p>既然选择使用当前的框架、请遵循其标准</p>
<p>vue.js引用地址 <code>&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</code></p>
<iframe height="300" scrolling="no" title="Vue.js小案例" src="//codepen.io/ntscshen/embed/preview/vyeWOe/?height=300&theme-id=26516&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/ntscshen/pen/vyeWOe/" target="_blank" rel="external">Vue.js小案例</a> by ntscshen@163.com (<a href="http://codepen.io/ntscshen" target="_blank" rel="external">@ntscshen</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p><a href="http://codepen.io/ntscshen/pen/vyeWOe/" target="_blank" rel="external">Vue.js小案例1</a> </p>
<blockquote>
<p>vue构造器是由一个作用域(el: ‘#app’)和一个数据中心组成( data:[] )</p>
</blockquote>
<h4 id="Vue常用指令"><a href="#Vue常用指令" class="headerlink" title="Vue常用指令"></a>Vue常用指令</h4><blockquote>
<p>指令：带有 <strong>v-</strong> 前缀的特殊属性，指令属性的值、语气是 <strong>单一JavaScript表达式</strong> 。指令的职责就是当其表达式的值改变时相应地将某些行为应用到DOM上</p>
</blockquote>
<ol>
<li>v-model</li>
<li>v-for循环</li>
<li>v-on:click绑定事件，methods( <strong>vue中单独提供的接口添加方法</strong> )</li>
</ol>
<blockquote>
<p>案例1：点击添加按钮、循环添加一组数据(数组、对象)</p>
<p>案例2：点击按钮div元素消失</p>
<p>案例3：todolist; TODO：使用bootstrap( 只需要记忆class类名的框架 )</p>
<p>案例4：v-if随机数 Math.random()</p>
<p>案例5：显示隐藏</p>
</blockquote>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><blockquote>
<p>因为 <strong>v-if</strong> 是一个指令(指令的职责就是当其表达式的值改变时相应地将某些行为应用到DOM上)，需要将它添加到一个元素上。我们可以把一个 <strong><template></template></strong> 元素当做包装元素，并在上面使用 <strong>v-if</strong> ,最终的渲染结果不会包含它</p>
<p><strong>v-else</strong> 元素必须紧跟在 <strong>v-if</strong> 或 <strong>v-show</strong> 元素的后面 — 否则它不能被识别</p>
<p><strong>v-show</strong> 的元素会始终渲染并保持在DOM中、简单的切换元素的CSS属性 <strong>display</strong> 。并且其不支持 <strong><template></template></strong> 语法</p>
</blockquote>
<h5 id="v-if-VS-v-show"><a href="#v-if-VS-v-show" class="headerlink" title="v-if VS v-show"></a><strong>v-if</strong> VS <strong>v-show</strong></h5><ul>
<li><code>v-if</code> 是真实的条件渲染，应为它会确保条件块在切换当中适当地销毁与重建条件内的事件监听器和子组件</li>
<li><code>v-if</code> 它是 <strong>惰性的</strong> ：如果在初始渲染时条件为假，则什么也不做 — 在条件第一次变为真时才开始局部编译( 编译会被缓存起来 )</li>
<li>相比之下， <code>v-show</code> 简单的多 — 元素始终被编译并保留，只是简单地基于CSS切换</li>
<li>一般来说， <code>v-if</code> 有更高的切换消耗而 <code>v-show</code> 有更高的初始渲染消耗。因此，如果需要频繁切换使用 <code>v-show</code> 较好，如果在运行时条件不大可能改变则使用 <code>v-if</code> 较好。</li>
</ul>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><blockquote>
<p><strong>v-for</strong> 指令根据一组数组的选项列表进行渲染。以 <strong>item in items</strong> 形式的特殊语法， <strong>items</strong> 是源数据数组并且 <strong>item</strong> 是数组元素迭代的别名</p>
</blockquote>
<ul>
<li><p>在 <code>v-for</code> 快中，我们拥有对父作用域属性的完全访问权限。 <code>v-for</code> 还支持一个可选的第二个参数为当前项的索引</p>
</li>
<li><p>也可以使用 <code>of</code> 替代 <code>in</code> 作为分隔符，因为它是最接近JavaScript迭代器的语法</p>
</li>
<li><p><strong>基本用法</strong> ( 数组迭代 )</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// item 项目</div><div class="line">&lt;ul id=&quot;Demo1&quot;&gt;</div><div class="line">  &lt;li v-for=&quot;item in items&quot;&gt;&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">&lt;script&gt;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">	el: &apos;#Demo1&apos;,</div><div class="line">	data: &#123;</div><div class="line">		items: [</div><div class="line">          &#123;message: &apos;Foo&apos;&#125;,</div><div class="line">          &#123;message: &apos;Bar&apos;&#125;,</div><div class="line">          &#123;message: &apos;Shen&apos;&#125;</div><div class="line">		]</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>用法二</strong> </p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 在v-for 快中，我们拥有对父作用域属性的完全访问权限。v-for还支持一个可选的第二个参数作为当前项目的索引</div><div class="line">// 您也可以使用of 代替 in 作为分隔符，因为它是最接近JavaScript迭代器的语法</div><div class="line">&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;ul id=&quot;Example&quot;&gt;</div><div class="line">  &lt;li v-for=&quot;(item, index) in items&quot;&gt;</div><div class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</div><div class="line">  &lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: &apos;#Example&apos;,</div><div class="line">  data: &#123;</div><div class="line">    parentMessage: &apos;Parent&apos;,</div><div class="line">    items: [</div><div class="line">      &#123;message: &apos;Foo&apos;&#125;,</div><div class="line">      &#123;message: &apos;Bar&apos;&#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>用法三</strong></p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 如果同v-if模板，你可以用带有v-for 的 &lt;template&gt;标签来渲染多个元素快</div><div class="line">  &lt;ul&gt;</div><div class="line">  	&lt;template v-for=&quot;item in items&quot;&gt;</div><div class="line">		&lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;</div><div class="line">      	&lt;li style=&quot;height: 5px; background-color: #efe0ce;&quot;&gt;&lt;/li&gt;</div><div class="line">    &lt;/template&gt;</div><div class="line">  &lt;/ul&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>基础用法</strong>  -  对象迭代</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 可以使用 v-for 通过一个对象的属性来迭代</div><div class="line">// (value, key, index) in object</div><div class="line">// 顺序严格规定(value(1:值), key(2:键), index(3:索引))</div><div class="line">// value 值</div><div class="line">// key 键</div><div class="line">// index 索引</div><div class="line">&lt;ul id=&quot;object&quot;&gt;</div><div class="line">  &lt;li v-for=&quot;value in object&quot;&gt;</div><div class="line">  	&#123;&#123; value &#125;&#125;</div><div class="line">  &lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;script&gt;</div><div class="line">var vm = new Vue([</div><div class="line">  el: &quot;#object&quot;,</div><div class="line">  data: &#123;</div><div class="line">    object: &#123;</div><div class="line">      name: &apos;ntscshen&apos;,</div><div class="line">  	  gender: &apos;男&apos;,</div><div class="line">  	  age: 24,</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">]);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><img src="http://occeqxmsk.bkt.clouddn.com/022559.jpg" alt="http://occeqxmsk.bkt.clouddn.com/022559.jpg"></p>
</li>
</ul>
<blockquote>
<p>数组和对象迭代总结：( 顺序严格规定 )</p>
<p>1、数组：v-for=”(item, index) in items” 内容，索引</p>
<p>2、对象：v-for=”(value, key, index) in object” 值，键，索引</p>
<p>3、整数：v-for=”n in 10”</p>
<p>4、组件：在自定义组件中，你可以想任何普通元素一样使用 v-for</p>
</blockquote>
<h4 id="缩写："><a href="#缩写：" class="headerlink" title="缩写："></a>缩写：</h4><blockquote>
<p>Vue为两个最为常用的指令提供了特别的缩写</p>
</blockquote>
<ul>
<li><strong>v-bind:href</strong> 缩写 <strong>:href</strong> </li>
<li><strong>v-on:click</strong> 缩写 <strong>@click</strong> </li>
</ul>
<p>​    </p>
<h3 id="vue监听"><a href="#vue监听" class="headerlink" title="vue监听"></a>vue监听</h3><ul>
<li><p>监听数据值的变化( 当改变时、修改内容 )</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">	el: &apos;#app&apos;,</div><div class="line">	data: &#123;</div><div class="line">        num1: 0,</div><div class="line">		num2: 10,</div><div class="line">		total: 0</div><div class="line">	&#125;,</div><div class="line">	watch: &#123;</div><div class="line">      &quot;num1&quot;:function(newval,oldval)&#123;</div><div class="line">		if(this.num1 &gt;= 3)&#123;</div><div class="line">          this.total = this.total - this.num2;</div><div class="line">		&#125;</div><div class="line">      &#125;</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Class与Style绑定"><a href="#Class与Style绑定" class="headerlink" title="Class与Style绑定"></a>Class与Style绑定</h2><blockquote>
<p>数据绑定一个常见需求是 - 操作元素的class列表和它的内联样式。因为它们都是属性，我们可以用v-bind处理。</p>
</blockquote>
<h4 id="class"><a href="#class" class="headerlink" title=":class"></a>:class</h4><ul>
<li><code>:class=&quot;{red: isRed}&quot;</code></li>
<li><code>:class=&quot;{classA,classB}&quot;</code> data数据中映射类名</li>
<li><code>:class=&quot;{&#39;class-A&#39;:isA,&#39;class-B:isB&#39;}&quot;</code> 在字面量方式里 - 第一方法的衍生</li>
<li><code>:class=[classA,{&#39;class-C&#39;:isC,&#39;class-B&#39;:isB}]</code> 组合方式</li>
</ul>
<h4 id="style"><a href="#style" class="headerlink" title=":style"></a>:style</h4><ul>
<li><p><code>:style=&quot;{fontSize: size + &#39;px&#39;}&quot;</code></p>
</li>
<li><p><code>:style=&quot;{styleObjectA,styleObjectB}&quot;</code> data数据映射</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">data: &#123;</div><div class="line">  styleObjectA:&#123;</div><div class="line">    color: &apos;red&apos;,</div><div class="line">    fontSize: &apos;100px&apos;</div><div class="line">  &#125;,</div><div class="line">  styleObjectB:&#123;</div><div class="line">    background-color: &apos;pink;</div><div class="line">    border: &apos;2px solid red&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>为元素绑定动态的属性、要使用v-bind这个质量、质量就是一些特别的属性、一般以 <code>v-</code> 开头</p>
</li>
<li><p>在元素上面动态的去应用一些CSS类、使用 <code>v-bind</code> 指令绑定 <code>class</code> 属性</p>
<ul>
<li><p>对象</p>
</li>
<li><p>数组  </p>
<ul>
<li><p><code>[buttonClass, colorClass]</code> 映射对应的Class类名、在 <code>data</code> 数据中添加 <code>key</code> 和 <code>映射的类名</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var dataSource = &#123;</div><div class="line">	buttonClass: &apos;ui button&apos;,// ui button 类名</div><div class="line">	colorClass: &apos;violet&apos;// violet 类名</div><div class="line">&#125;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">	el: &apos;#app&apos;,</div><div class="line">	data: dataSource</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;app&quot;&gt;</div><div class="line">      &lt;div class=&quot;ui container&quot;&gt;</div><div class="line">        &lt;div class=&quot;ui hidden divider&quot;&gt;</div><div class="line">          &lt;button v-bind:class=&quot;[buttonClass, colorClass, classObject]&quot;&gt;按钮&lt;/button&gt;</div><div class="line">          &lt;h2 style=&quot;color: red;&quot;&gt;绑定类&lt;/h2&gt;</div><div class="line">          &lt;ul&gt;</div><div class="line">            &lt;li&gt;我们可以动态的去设置一下这个按钮的颜色 &lt;strog&gt;vm.colorClass=&quot;green&quot;&lt;/strog&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;有一些css类你可能希望，根据某一个值去动态的添加&lt;/li&gt;</div><div class="line">            &lt;li&gt;在绑定类的数组里给其添加变量&lt;strong&gt;&#123;loading: isLoading&#125;&lt;/strong&gt;&lt;/li&gt;</div><div class="line">            &lt;li style=&quot;color: violet&quot;&gt;这块的意思就是：&lt;p style=&quot;red&quot;&gt;如果应用里面的isLoading值是true的话、就会在这个元素的上面去添加一个loading这样的一个css类&lt;/p&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;在Data数据中添加&lt;p&gt;isLoading:false&lt;/p&gt;。之后在控制台动态的设置isLoading的值&lt;/li&gt;</div><div class="line">            &lt;li&gt;我们可以动态的去设置一下这个按钮的颜色 &lt;stro&gt;vm.colorClass=&quot;green&quot;&lt;/stro&gt;&lt;/li&gt;\</div><div class="line">            &lt;li&gt;表达式可以在v-bind:class=&quot;[isActive ? activeClass :&apos;&apos;, errorClass]&quot; 绑定类中去写&lt;/li&gt;</div><div class="line">            &lt;!-- &lt;div v-bind:class=&quot;[&#123;active:isActive&#125;,errorClass]&quot;&gt;&lt;/div&gt; --&gt;</div><div class="line">            &lt;!--</div><div class="line">              v-bind 有点类似于jQuery的css。只是在这之上映射了一层。data</div><div class="line">              如果直接这样。模板会跟加清晰</div><div class="line">              data: &#123;</div><div class="line">                styleObject: &#123;</div><div class="line">                  color: &apos;red&apos;,</div><div class="line">                  fontSize: &apos;14px&apos;;</div><div class="line">                &#125;</div><div class="line">              &#125;</div><div class="line">              &lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt;</div><div class="line">           --&gt;</div><div class="line">          &lt;/ul&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var vm = new Vue(&#123;</div><div class="line">        el: &apos;#app&apos;,</div><div class="line">        data: &#123;</div><div class="line">          buttonClass: &apos;ui button&apos;,</div><div class="line">          colorClass: &apos;violet&apos;,</div><div class="line">          isLoading: true,</div><div class="line">          error: null</div><div class="line">        &#125;,</div><div class="line">        computed:&#123;</div><div class="line">          classObject: function()&#123;</div><div class="line">            return &#123;</div><div class="line">              loading: this.isLoading &amp;&amp; !this.error,</div><div class="line"></div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[需求文档]]></title>
      <url>http://ntscshen.com/2016/11/28/%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3.html</url>
      <content type="html"><![CDATA[<p>需求文档</p>
<ol>
<li>无论是正式的产品需求或是Demo需求( <strong>必须要出产品需求</strong> )</li>
<li>基于对当前产品需求的了解之后 - 才能运用对应的技术站进行开发</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac上网络抓包Charles]]></title>
      <url>http://ntscshen.com/2016/11/19/Mac%E4%B8%8A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Charles.html</url>
      <content type="html"><![CDATA[<p>抓包？就是将<a href="http://baike.baidu.com/view/1542295.htm" target="_blank" rel="external">网络传输</a>发送与接收的<a href="http://baike.baidu.com/view/25880.htm" target="_blank" rel="external">数据包</a>进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进行数据截取等。</p>
<p>为什么调试配置Host？ 我们知道在网络上访问网站，要首先通过DNS服务器把网络域名（www.XXXX.com）解析成61.XXX.XXX.XXX的IP地址后，我们的计算机才能访问。要是对于每个域名请求我们都要等待域名服务器解析后返回IP信息，这样访问网络的效率就会降低，而Hosts文件就能提高解析效率。</p>
<ul>
<li>在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务要输入难记的IP地址，对不少人来说相当麻烦。现在可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候我们输入这个服务器的名字就行了。</li>
<li>对于Lotus的服务器和一些<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="external">数据库</a>服务器，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。</li>
</ul>
<p><a href="http://www.charlesproxy.com/" target="_blank" rel="external">Charles</a> Mac下常用的网络封包截取工具(免费30天 - 试用期过后建议购买<a href="http://www.charlesproxy.com/" target="_blank" rel="external">正版)</a></p>
<p><img src="http://occeqxmsk.bkt.clouddn.com/30Day.jpg" alt="http://occeqxmsk.bkt.clouddn.com/30Day.jpg"></p>
<p>Charles通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析</p>
<h3 id="Charles主要功能"><a href="#Charles主要功能" class="headerlink" title="Charles主要功能"></a>Charles主要功能</h3><ol>
<li>截取Http和Https网络封包。</li>
<li>支持重发网络请求，方便前后端调试。</li>
<li>支持修改网络请求参数。</li>
<li>支持网络请求的截获并动态修改。</li>
<li>支持模拟满网速网络</li>
</ol>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>下载好Charles - 打开下载包( <code>.dmg</code>后缀的文件 )后将Charles拖到<code>Application</code>目录下即可。</p>
<p>启动Charles后、第一次Charles会请求您给它设置系统代理的权限。图例如下！</p>
<blockquote>
<p>源：</p>
</blockquote>
<p><img src="http://occeqxmsk.bkt.clouddn.com/QQ20161120-1-2x.png" alt="http://occeqxmsk.bkt.clouddn.com/QQ20161120-1-2x.png"></p>
<blockquote>
<p>译：</p>
</blockquote>
<p><img src="http://occeqxmsk.bkt.clouddn.com/AutomaticMacOSConfigurationProxy-translate.jpg" alt="http://occeqxmsk.bkt.clouddn.com/AutomaticMacOSConfigurationProxy-translate.jpg"></p>
<h5 id="Firefox代理服务器配置"><a href="#Firefox代理服务器配置" class="headerlink" title="Firefox代理服务器配置"></a>Firefox代理服务器配置</h5><blockquote>
<p>源：</p>
</blockquote>
<p><img src="http://occeqxmsk.bkt.clouddn.com/Charle-Firefox-Proxy.png" alt="http://occeqxmsk.bkt.clouddn.com/Charle-Firefox-Proxy.png"></p>
<blockquote>
<p>译：</p>
</blockquote>
<p><img src="http://occeqxmsk.bkt.clouddn.com/Charle-Firefox-Proxy.jpg" alt="http://occeqxmsk.bkt.clouddn.com/Charle-Firefox-Proxy.jpg"></p>
<h4 id="在Firefox中打开-https-addons-mozilla-org-zh-CN-firefox-addon-charles-proxy"><a href="#在Firefox中打开-https-addons-mozilla-org-zh-CN-firefox-addon-charles-proxy" class="headerlink" title="在Firefox中打开 https://addons.mozilla.org/zh-CN/firefox/addon/charles-proxy/"></a>在Firefox中打开 <a href="https://addons.mozilla.org/zh-CN/firefox/addon/charles-proxy/" target="_blank" rel="external">https://addons.mozilla.org/zh-CN/firefox/addon/charles-proxy/</a></h4><blockquote>
<p>源：</p>
</blockquote>
<p><img src="http://occeqxmsk.bkt.clouddn.com/QQ20161120-3-2x.png" alt="http://occeqxmsk.bkt.clouddn.com/QQ20161120-3-2x.png"></p>
<blockquote>
<p>译：</p>
</blockquote>
<p><img src="http://occeqxmsk.bkt.clouddn.com/firefox-charles-proxy.jpg" alt="http://occeqxmsk.bkt.clouddn.com/firefox-charles-proxy.jpg"></p>
<p>这样在Firefox可以抓包<code>Proxy -&gt; Mozilla Firefox Proxy</code></p>
<p><img src="http://occeqxmsk.bkt.clouddn.com/062002.jpg" alt="http://occeqxmsk.bkt.clouddn.com/062002.jpg"></p>
<h3 id="将Charles设置成系统代理"><a href="#将Charles设置成系统代理" class="headerlink" title="将Charles设置成系统代理"></a>将Charles设置成系统代理</h3><h3 id="Charles主界面"><a href="#Charles主界面" class="headerlink" title="Charles主界面"></a>Charles主界面</h3><ul>
<li><p>Structure：结构( 视图将网络请求按访问的域名分类 )</p>
</li>
<li><p>Sequence：先后次序( 视图将网络请求按访问的时间排序 )</p>
<blockquote>
<p>根据具体的需求在这两个视图之间来回切换、大多数情况下截获的请求会很多，Charles提供了一个简单Filter功能，可以输入关键字来快速筛选URL中带指定关键字的网络请求</p>
</blockquote>
</li>
<li><p>对于具体的网络请求</p>
<ul>
<li>若请求的内容是POST表单、Charles会自动将表单进行分项显示</li>
<li>若是JSON格式的内容、Charles会自动将JSON内容格式化</li>
<li>若是图片、Charles会显示出图片的预览</li>
</ul>
</li>
</ul>
<p><img src="http://occeqxmsk.bkt.clouddn.com/homgpage1.jpg" alt="http://occeqxmsk.bkt.clouddn.com/homgpage1.jpg"></p>
<h3 id="抓包工具之断点修改-重点"><a href="#抓包工具之断点修改-重点" class="headerlink" title="抓包工具之断点修改( 重点 )"></a>抓包工具之断点修改( 重点 )</h3><blockquote>
<p>更改返回数据来测试临界情况：这种做法可以让一个前端开发人员独立完成测试而不用拉一个后端一起联调，并且各种特殊维度，临界点都可以独立完成。仅仅自己在青花瓷上改来改去就可以达到效果了。</p>
</blockquote>
<p><code>在实际的工作中、你可以经常用来把某些值改为临界情况 - 以查看当前页面在处理这些临界状况收的反应、这样比(找后端联调\找临界点的测试账号)这些数据成本要低得多，</code></p>
<h3 id="截获IPhone上的网络封包"><a href="#截获IPhone上的网络封包" class="headerlink" title="截获IPhone上的网络封包"></a>截获IPhone上的网络封包</h3><blockquote>
<p>Charles通常用来截获本地上的网络封包、当我们需要时、可以用来截取其他设备上的网络请求，如下</p>
</blockquote>
<ol>
<li><p>截取IPhone上的网络请求、首先打开Charles的代理功能<code>Proxy -&gt; Proxy Settings</code>填入代理端口<code>8888</code> 并勾选<code>&quot;Enable transparent HTTP proxying&quot;</code> 完成在Charles上的设置</p>
<p><img src="http://occeqxmsk.bkt.clouddn.com/proxy-settings.jpg" alt="http://occeqxmsk.bkt.clouddn.com/proxy-settings.jpg"></p>
</li>
<li><p>在手机上<code>&quot;设置&quot; -&gt; &quot;无线局域网&quot;</code> 找到当前链接的WIFI名、点击右侧详情( 感叹号 )，在最底部找到<code>HTTP代理</code>、修改成手动</p>
<ol>
<li><p><code>设置 - 无线局域网</code></p>
<p><img src="http://images0.cnblogs.com/blog2015/717809/201507/051346395823455.png" alt="http://images0.cnblogs.com/blog2015/717809/201507/051346395823455.png"></p>
</li>
<li><p>服务器：<code>当前Charles运行所在电脑的IP：系统偏好设置 -&gt; 网络</code> 选中现在连着的网（大部分人应该都是WiFi吧）</p>
</li>
<li><p>​</p>
<p><img src="http://images0.cnblogs.com/blog2015/717809/201507/051341085151931.png" alt="http://images0.cnblogs.com/blog2015/717809/201507/051341085151931.png"></p>
</li>
<li><p>服务器 ： <code>电脑IP地址</code>  ，端口号: <code>8888</code>，</p>
<p><img src="http://images0.cnblogs.com/blog2015/717809/201507/051346589484842.png" alt="http://images0.cnblogs.com/blog2015/717809/201507/051346589484842.png"></p>
</li>
</ol>
</li>
<li><p>设置完成后、打开iphone上的任意与需要网络的软件、就可以在Charles上看到弹出如下信息,点击<code>&quot;Allow&quot;</code>即可完成设置 - 这是会有一大波抓包信息的展示</p>
<p><img src="http://occeqxmsk.bkt.clouddn.com/charles-proxy-confirm-1.jpg" alt="http://occeqxmsk.bkt.clouddn.com/charles-proxy-confirm-1.jpg"></p>
</li>
</ol>
<h3 id="模拟慢速网络"><a href="#模拟慢速网络" class="headerlink" title="模拟慢速网络"></a>模拟慢速网络</h3><blockquote>
<p>在开发时、我们常常需要模拟慢网速或者高延迟的网络、以测试在移动网络下、开发的产品是否显示正常</p>
</blockquote>
<ol>
<li>在Charles菜单中，选择<code>&quot;Proxy - Throttle Setting&quot;</code>在之后弹出的对话框中、勾选上<code>&quot;Enable Throttling&quot;</code>,并且可以设置不同网速的类型如下</li>
</ol>
<h3 id="修改网络请求内容"><a href="#修改网络请求内容" class="headerlink" title="修改网络请求内容"></a>修改网络请求内容</h3><ol>
<li>有时候伪类调试服务器的接口、我们需要反复尝试不同的参数的网络请求，Charles可以很方便的提供网络请求的修改和重发功能、在网络请求上点击右键,选择<code>&quot;Edit&quot;</code>,即可编辑</li>
<li>我们可以修改请求的任何信息<ol>
<li>URL地址</li>
<li>端口号</li>
<li>参数</li>
<li>等等</li>
</ol>
</li>
<li>之后点击<code>&quot;Execute&quot;</code>即可发送该修改后的网络请求。Charles支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[页面操作iFrame的Dom]]></title>
      <url>http://ntscshen.com/2016/11/18/%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9CiFrame%E7%9A%84Dom.html</url>
      <content type="html"><![CDATA[<p>没有过时的技术只有变态的需求</p>
<blockquote>
<p>contentWindow兼容主流浏览器、获取子窗口的window对象;</p>
<p>指定的frame或iframe所在的window对象</p>
</blockquote>
<p>document对象是window对象的一个子对象;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'iframe ID'</span>).contentWindow.document来获取iframe的<span class="built_in">document</span>对象。相当于contentDocument属性</div><div class="line"></div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'userIframe'</span>).onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"> </div><div class="line"><span class="comment">// (LEPass &amp;&amp; LEPass.isLogin) 登录返回true、没登录放回false document.getElementById('userIframe').contentDocument.body.onclick = function(a)&#123;</span></div><div class="line">    <span class="keyword">if</span>(a.target.className == <span class="string">'ntscshen'</span> &amp;&amp; !(LEPass &amp;&amp; LEPass.isLogin()))&#123;</div><div class="line">      <span class="comment">// 登录内容信息</span></div><div class="line">      LEPass.openLoginPage(<span class="built_in">window</span>.location.href, <span class="string">''</span>, &#123;</div><div class="line">        ...</div><div class="line">        ...</div><div class="line">      &#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Atom编辑器的使用技巧]]></title>
      <url>http://ntscshen.com/2016/10/08/Atom%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html</url>
      <content type="html"><![CDATA[<h1 id="在Atom中快速打开命令行"><a href="#在Atom中快速打开命令行" class="headerlink" title="在Atom中快速打开命令行"></a>在Atom中快速打开命令行</h1><p>实际开发的痛点：经常从编辑器切换到命令行( 虽然可以使用CmdTap类似的工具 )、但找到当前目录是需要花费很多时间</p>
<p><code>apm install open-terminal-here</code></p>
<ul>
<li>打开当前项目的顶级目录<code>alt-cmd-t</code></li>
<li>打开当前文件所在的位置<code>ctrl-cmd-t</code></li>
</ul>
<h3 id="在Atom中新建文件、重命名、移动"><a href="#在Atom中新建文件、重命名、移动" class="headerlink" title="在Atom中新建文件、重命名、移动"></a>在Atom中新建文件、重命名、移动</h3><p><code>advanced-open-file</code></p>
<ul>
<li>alt-cmd-o 新建文件</li>
<li>shift-cmd-p rename重命名文件</li>
<li>ctrl-0<ul>
<li>m 修改</li>
<li>a 添加文件</li>
<li>shift-a 添加文件夹</li>
<li>d 复制</li>
</ul>
</li>
</ul>
<h3 id="自定义snippets-cson"><a href="#自定义snippets-cson" class="headerlink" title="自定义snippets.cson"></a>自定义snippets.cson</h3><ul>
<li>atom-ternjs</li>
</ul>
<h2 id="Atom快捷键的使用"><a href="#Atom快捷键的使用" class="headerlink" title="Atom快捷键的使用"></a>Atom快捷键的使用</h2><p>关闭标签后 - 后悔<code>ctrl-shift-t</code></p>
<p>样式表修改 Atom styless</p>
<p>树形视图的修改和浏览</p>
<ul>
<li>cmd-\ 打开关闭树形试图( cmd-k-b )</li>
<li>转移视图光标( ctrl-0 )</li>
<li>ctrl-[  展开收缩 树形视图   ]</li>
<li>ctrl-alt[  递归展开收缩  ]</li>
<li>J向上</li>
<li>k向下</li>
<li>展开目录 L</li>
<li>收起目录H</li>
</ul>
<h4 id="添加文件和目录"><a href="#添加文件和目录" class="headerlink" title="添加文件和目录"></a>添加文件和目录</h4><ul>
<li>ctrl - 0 - add ( a ) 创建时候可以建立对应目录下的文件夹</li>
<li>ctrl-0 shift-a 创建目录</li>
</ul>
<h4 id="移动和重命名、复制粘贴删除"><a href="#移动和重命名、复制粘贴删除" class="headerlink" title="移动和重命名、复制粘贴删除"></a>移动和重命名、复制粘贴删除</h4><ul>
<li>ctrl-0 move( m ) 移动到对应的文件目录下、可以用来重命名文件或者目录</li>
<li>duplicate( d )复制</li>
</ul>
<h3 id="APM-是atom-package-menage-atom包管理工具"><a href="#APM-是atom-package-menage-atom包管理工具" class="headerlink" title="APM 是atom package menage atom包管理工具"></a>APM 是atom package menage atom包管理工具</h3><ul>
<li>可以让用户在命令行下安装跟新删除编辑器的package</li>
<li>apm search color 在命令行中显示对应的包</li>
<li>apm home color-picker 使用默认的浏览器打开对应包的首页</li>
<li>apm list包列表<ul>
<li>Community packages 社区包</li>
<li>Built-in Atom packages Atom内置包</li>
</ul>
</li>
</ul>
<p>Snippets代码片段 alt+shift+s代码片段的介绍和一些简写形式</p>
<h3 id="ATOM插件-Community-packages"><a href="#ATOM插件-Community-packages" class="headerlink" title="ATOM插件 - Community packages"></a>ATOM插件 - Community packages</h3><ul>
<li>atom汉化<code>atom-simplified-chinese-menu</code>插件</li>
</ul>
<ul>
<li><p>tool bar插件</p>
</li>
<li><p><code>atom-ternjs</code> JavaScript和Node自动补全插件 - 必备</p>
</li>
<li><p><code>highlight-selected</code> 高亮所有和当前选中单词一样的单词，IDE标配。</p>
</li>
<li><p><code>autocomplete-paths</code> 路径补全插件</p>
</li>
<li><p><a href="https://link.zhihu.com/?target=https%3A//atom.io/packages/linter" target="_blank" rel="external">linter**</a><strong> 和 </strong><a href="https://link.zhihu.com/?target=https%3A//atom.io/packages/linter-eslint" target="_blank" rel="external">linter-eslint**</a></p>
<p>linter-eslint依赖linter，安装之后就可以按照.eslintrc文件里面配置校验JS了。</p>
</li>
</ul>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul>
<li><code>file-icons</code> 高颜值的文件图标</li>
<li><code>pigments</code> 代码颜色可视化<code>修改颜色位置 Marker TYpe: dot</code></li>
<li><code>indent-guide-improved</code>  代码大括号范围提示。</li>
<li><code>minimap</code> 类sublime的小地图功能</li>
<li><code>fold-comments</code> 注释快速折叠 ctrl-shift-/ <code>快速注释会打出 顿号</code></li>
<li><code>elastic-tabstops</code> 弹性制表位  </li>
<li><code>highlight-selected</code> 高亮所有和当前选中单词一样的单词<ul>
<li><code>quick-highlight</code> 高亮、同时高亮多处非选中的单词，在读代码时挺有用</li>
<li><code>highlight-line</code> 高亮当前行</li>
</ul>
</li>
<li>​</li>
</ul>
<h2 id="IDE功能补全"><a href="#IDE功能补全" class="headerlink" title="IDE功能补全"></a>IDE功能补全</h2><ul>
<li><code>emmet</code></li>
<li><code>atom-ternjs</code> 提供了了比较精确的代码补全功能ECMAScript、DOM/BOM、NodeJS</li>
<li><code>autocomplete-paths</code> 路径补全</li>
<li><code>advanced-open-file</code> 翻遍的打开创建文件 <code>cmd+alt+o</code></li>
<li><code>autoclose-html</code> 自动闭合标签</li>
<li><code>atom-beautify</code> 代码美化、自己支持的语法不多、语法例如 PHP、MarkDown、Python 则需系统安装一些额外的插件</li>
<li><code>editorconfig</code> 空格和utf-8、<a href="http://editorconfig.org/" target="_blank" rel="external">EditorConfig</a>帮助开发人员保持不同的编辑器之间是一致的编码风格</li>
<li><code>Run In Browser</code> 打开浏览器 <strong>ctrl</strong> + <strong>alt</strong> + <strong>r</strong></li>
<li><code>Bracket Matcher</code> 括号匹配</li>
<li><code>docblockr</code> 注释</li>
<li><code>autocomplete-emojis</code> 表情包</li>
<li><code>Open Terminal Here</code> 打开当前文件命令行<ul>
<li>当前目录终端<code>ctrl-cmd-t</code></li>
<li>项目目录终端<code>alt-cmd-t</code></li>
</ul>
</li>
<li><code>regex-railroad-diagram package</code> 正则</li>
<li><code>Activate Power Mode</code> 爆炸</li>
<li>css-snippets</li>
<li>javascript-snippets</li>
<li>jQuery-snippets</li>
</ul>
<ol>
<li>command palette</li>
<li>dev live reload</li>
<li>​</li>
</ol>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><ol>
<li>markdown-assistant <code>剪切板上传图片</code></li>
<li>qiniu-uploader <code>七牛图床</code></li>
<li>markdown-lists<h3 id="Markdown常见的用法"><a href="#Markdown常见的用法" class="headerlink" title="Markdown常见的用法"></a>Markdown常见的用法</h3></li>
</ol>
<ul>
<li>h1-h6</li>
<li><code>有序列表: *</code> 、 <code>无序列表: -</code></li>
<li>引用 <code>&gt;</code></li>
<li>图片img、加粗b、倾斜i</li>
<li>表格table</li>
<li><p>代码段code</p>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2></li>
<li><p><code>hyperclick</code> 可以跳转到变量定义的地方，也能识别import/require，点击模块名可以跳转到模块的内部。</p>
</li>
<li><code>js-hyperclick</code> 配合 <code>hyperclick</code> 使用</li>
<li>Atom全局配置ESLint<code>http://wrox.cn/article/100077190/</code></li>
<li><code>linter</code> 和 <code>linter-eslint</code></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[移动端基础事件（一）]]></title>
      <url>http://ntscshen.com/2016/09/22/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%BA%8B%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="html"><![CDATA[<h4 id="移动端事件"><a href="#移动端事件" class="headerlink" title="移动端事件"></a>移动端事件</h4><ul>
<li>touchstart  手指触摸屏幕时候触发</li>
<li>touched 手指离开屏幕时候触发</li>
<li>touchmove 手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。</li>
</ul>
<h4 id="addEventListener-‘事件名’-函数-匿名OR有名-false-冒泡和捕获"><a href="#addEventListener-‘事件名’-函数-匿名OR有名-false-冒泡和捕获" class="headerlink" title="addEventListener(‘事件名’,函数[匿名OR有名],false[冒泡和捕获]);"></a>addEventListener(‘事件名’,函数[匿名OR有名],false[冒泡和捕获]);</h4><ul>
<li>DOM中提供的注册事件监听器的方法</li>
</ul>
<ul>
<li>它允许给一个事件注册多个监听器。不会存在前后覆盖问题</li>
<li>在Chrome的模拟器下可以一直识别</li>
</ul>
<h4 id="Event-事件对象、事件函数中默认的第一个参数"><a href="#Event-事件对象、事件函数中默认的第一个参数" class="headerlink" title="Event 事件对象、事件函数中默认的第一个参数"></a>Event 事件对象、事件函数中默认的第一个参数</h4><ul>
<li>cancelBubble(取消冒泡) 阻止冒泡<code>console.dir(event);</code></li>
<li>target(标靶)  事件发生的位置<code>console.dir(event);</code></li>
<li>e.preventDefault();阻止默认事件<ul>
<li>阻止页面中的文字选中</li>
<li>阻止页面上的系统菜单、滚动条失效、overflow: auto;失效</li>
</ul>
</li>
</ul>
<h4 id="事件穿透"><a href="#事件穿透" class="headerlink" title="事件穿透"></a>事件穿透</h4><ol>
<li>PC鼠标事件、但事件的执行会有300ms的延迟</li>
<li>点击了页面之后 - 浏览器会记录点击下去的坐标</li>
<li>300ms后、在该坐标找到现在在这的元素 - 执行事件</li>
</ol>
<p>解决办法</p>
<ol>
<li>e.preventDefault(); 阻止默认事件</li>
<li>不在移动端使用鼠标事件</li>
<li>不用a标签做页面跳转(点透问题、防止误触a标签)、把a标签的href的跳转<code>e.preventDefault()</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 误触</span></div><div class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">        e.preventDefault();</div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mistake</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.isMove = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> aBlock = <span class="built_in">document</span>.querySelectorAll(<span class="string">'a'</span>);</div><div class="line">    aBlock[<span class="number">0</span>].addEventListener(<span class="string">'touchmove'</span>, mistake, <span class="literal">false</span>);</div><div class="line">    aBlock[<span class="number">0</span>].addEventListener(<span class="string">'touchend'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isMove) &#123;</div><div class="line">            <span class="built_in">window</span>.location.href = <span class="string">'http://www.baidu.com'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>.isMove = <span class="literal">false</span>;</div><div class="line">    &#125;, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[页面性能管理]]></title>
      <url>http://ntscshen.com/2016/09/01/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86.html</url>
      <content type="html"><![CDATA[<h3 id="网页生成的过程、大致分成五步"><a href="#网页生成的过程、大致分成五步" class="headerlink" title="网页生成的过程、大致分成五步"></a>网页生成的过程、大致分成五步</h3><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png" alt=""></p>
<blockquote>
<p>第一步到第三幕都非常快( 一刹那 )</p>
<ul>
<li>“生成布局” - flow - layout(布局) - Render Tree( 渲染树 )</li>
<li>“绘制” - paint</li>
<li>flow + paint = render(渲染)</li>
</ul>
</blockquote>
<h3 id="重排和重绘"><a href="#重排和重绘" class="headerlink" title="重排和重绘"></a>重排和重绘</h3><ul>
<li>重绘：元素外观改变所触发的浏览器行为(visibility\outline\背景色)</li>
<li>重排：渲染树重新计算</li>
</ul>
<blockquote>
<p>“重绘”不一定”重排”</p>
<p>“重排”必定”重绘”</p>
</blockquote>
<p>从性能角度考虑</p>
<ul>
<li>经量不把 <code>读操作</code> 和  <code>写操作</code> 在一个里面</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad</span></div><div class="line">div.style.left = div.offsetLeft + <span class="number">10</span> + <span class="string">"px"</span>;</div><div class="line"><span class="comment">// Good</span></div><div class="line"><span class="keyword">var</span> left = div.offsetLeft;</div><div class="line">div.style.left = left + <span class="number">10</span> + <span class="string">"px"</span>;</div></pre></td></tr></table></figure>
<h2 id="一般规则如下"><a href="#一般规则如下" class="headerlink" title="一般规则如下"></a>一般规则如下</h2><ul>
<li>样式表越简单、重排和重绘就会越快</li>
<li>重排和重绘的DOM元素层级越高、成本就越高</li>
<li>table元素的重排和重绘成本、高于div元素</li>
</ul>
<h2 id="提高性能的技巧"><a href="#提高性能的技巧" class="headerlink" title="提高性能的技巧"></a>提高性能的技巧</h2><ol>
<li><p>读操作和写操作、应该放在一起( 不要在两个读操作之间、加入一个写操作 )</p>
</li>
<li><p>若某个样式是通过重排得到的、把结果缓存下来、避免下一次用到的时候、浏览器重排</p>
<ol>
<li>在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。</li>
</ol>
</li>
<li><p>不要在JS里一条条的修改样式、要通过改变class或者csstext属性、一次性地改变样式</p>
</li>
<li><p>将元素设置<code>display: none</code>( 需要一次重排和重绘 )、然后对这个几点进行N+次操作、最后再回复显示( 需要一次重排和重绘 )、这样、使用<code>两次</code>重新渲染、取代可能的N+次的重新渲染</p>
</li>
<li><p>position属性为absolute或fixed的元素时候、重排的开销比较小、因为不用考虑它对其他元素的影响</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// bad   </span></div><div class="line"><span class="keyword">var</span> top = <span class="number">10</span>;   </div><div class="line">ele.style.left = left + <span class="string">"px"</span>;   </div><div class="line">ele.style.top = top + <span class="string">"px"</span>;   <span class="comment">// Good   </span></div><div class="line"><span class="keyword">var</span> top = <span class="number">10</span>,left = <span class="number">10</span>;   </div><div class="line">$(<span class="string">'ele'</span>).css(&#123;<span class="attr">left</span>: left,<span class="attr">top</span>: top&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="css的效率"><a href="#css的效率" class="headerlink" title="css的效率"></a>css的效率</h2><blockquote>
<p>浏览器读取CSS选择器有一个很重要的原则，它们从右到左读取。这意味这像 <code>ul &gt; li a[title=&quot;home&quot;]</code>这样的选择器， <code>a[title=&quot;home&quot;]</code> 将是最先被读取的。</p>
</blockquote>
<ul>
<li>ID是唯一的、所以不需要任何的标签进行修饰、这样只会让效率更低<code>ul#main{}</code></li>
<li><strong>没有什么比用后代选择器更糟糕的做法了</strong> 后代选择器是css选择器里最昂贵的选择器</li>
</ul>
<h2 id="总结的优化技巧"><a href="#总结的优化技巧" class="headerlink" title="总结的优化技巧"></a>总结的优化技巧</h2><h4 id="CSS优化"><a href="#CSS优化" class="headerlink" title="CSS优化"></a>CSS优化</h4><ul>
<li>CSS尽量避免使用后代选择器 - 使用子代选择器代替<code>没有比后代选择器跟糟糕的</code></li>
<li>在书写CSS时、使用类选择器”代替”元素选择器<code>类选择器获取速度优于元素选择器</code></li>
<li>样式表越简单、嵌套层级越小( 重排和重绘就会越快 ) <code>sass书写不大于三层</code></li>
</ul>
<h4 id="jQuery优化"><a href="#jQuery优化" class="headerlink" title="jQuery优化"></a>jQuery优化</h4><ul>
<li><p>选择器优化</p>
<ul>
<li>尽可能使用ID选择器( 唯一的、最快的 )，因为jQuery源码中调用的是<code>document.getElementById()</code>、不要与其他选择器混搭</li>
<li>class选择器次之<code>调用原生getElementByClassName()方法</code>、指定类选择器的上下文、以缩小选择范围(默认：document)<code>$(&#39;.class&#39;,&#39;#div1&#39;)</code>;</li>
<li>多级查找中、选择器的子类越详细越好<code>$(&quot;.data li.li1&quot;)</code> </li>
<li>$parent.find(‘p.child’) 最快查找子元素的方法<code>find()会调用原生的 getElementByTagName方法</code></li>
<li>经可能的缓存<code>(缓存比不缓存快了2-3倍)</code> <code>为什么要缓存得到的变量？就是减少访问DOM接口</code></li>
<li>使用链式写法、jQuery会自动缓存每一步的结果、链式比不链式写法快了25%左右</li>
</ul>
</li>
<li><p>DOM优化</p>
<ul>
<li><p>如果对一个DOM进行大量处理操作、使用.detach()方法、取出 - 处理 - 插入、使用.detach()方法比不使用时，快了60%。<code>.detach(分离)</code></p>
</li>
<li><p><code>.detach()</code>移除被选元素，包括所有文本和子节点。这个方法会保留 jQuery 对象中的匹配的元素，因而可以在将来再使用这些匹配的元素。会保留所有绑定的事件、附加的数据。<code>主要为了处理元素的大量DOM操作而生</code></p>
</li>
<li><p>改动DOM结构、先把它们合并，然后再一次性插入</p>
</li>
<li><p>不要使用匿名函数来用作事件处理、这样不利于调试、测试、维护和服用<code>$(&quot;#btn&quot;).on(&#39;click&#39;,&#39;a&#39;,myClick);function myClick(){...}</code></p>
</li>
<li><p>在DOM元素上存储数据</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ele = $(<span class="string">'#ele'</span>);</div><div class="line">ele.data(key,value);</div><div class="line"><span class="comment">// 修改</span></div><div class="line"><span class="keyword">var</span> ele = $(<span class="string">'#ele'</span>);</div><div class="line">$.data(ele[<span class="number">0</span>],key,value);</div><div class="line"><span class="comment">// 因为elem.data()方法是定义在jQuery函数的prototype对象上面的，而$.data()方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果可能的话使用自己的事件命名空间、这样方便地取消绑定而不影响其他的DOM元素事件绑定<code>$(&quot;#myClick&quot;).on(&quot;click.ntscshen&quot;,&quot;a&quot;,myEventHandler);$(&quot;#myClick&quot;).off(&quot;click.ntscshen&quot;)</code></p>
</li>
<li><p>不要处理不存在的元素<code>if($mySelection.length){...}</code></p>
</li>
<li><p>当某个事件后、如果要连续执行多个操作<code>使用自定义事件并使用自执行事件</code></p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">shen</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  $.trigger(<span class="string">'yang'</span>);</div><div class="line">&#125;</div><div class="line">$(<span class="built_in">document</span>).on(<span class="string">'yang'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  one();</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="其他的优化方案"><a href="#其他的优化方案" class="headerlink" title="其他的优化方案"></a>其他的优化方案</h4><ul>
<li>在JS内会用添加类名的方式修改”样式”属性<code>不要使用jquery.CSS({方法})</code>、使用添加类名的方式<code>$(&quot;#click&quot;).addClass(&quot;error&quot;);</code></li>
</ul>
<ul>
<li>使用事件委托进行处理的方式<code>就近原则</code></li>
<li>在注重性能的地方、请使用原生的Javascript代码</li>
<li>当需要大量的DOM操作时、先隐藏在内存中操作、在显示<code>只触发两次重排和重绘操作</code></li>
<li>定位元素的开销较小、不用考虑对其他元素的影响</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BFC]]></title>
      <url>http://ntscshen.com/2016/08/31/BFC.html</url>
      <content type="html"><![CDATA[<h3 id="BFC-快级格式化上下文"><a href="#BFC-快级格式化上下文" class="headerlink" title="BFC - 快级格式化上下文"></a>BFC - 快级格式化上下文</h3><blockquote>
<p>用于决定快盒子的布局及相互影响的区域</p>
</blockquote>
<ul>
<li>浮动</li>
<li>定位<code>absolute</code> OR <code>fixed</code></li>
<li>行内快级元素<code>display: inline-block</code></li>
<li>表格单元格<code>display: table-cell</code></li>
<li>表格标题<code>display: table-caption</code></li>
<li>切割<code>overflow: hidden;</code></li>
<li>弹性盒子<code>display: flex</code> OR <code>display: inline-flex</code></li>
</ul>
<p>快级格式化上下文对<code>定位</code>和<code>清除浮动</code>很重要</p>
<p>定位和清除浮动的样式规则适用于处于同一个快格式化上下文内的元素</p>
<p>浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只清除同一块格式化上下文中 在它前面的元素的浮动。</p>
<h5 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a>BFC布局规则</h5><ul>
<li><p>内部元素会在垂直方向、一个接着一个放置</p>
</li>
<li><p>每个元素的margin box的左边、与包含快border box的左边相接触<code>即使浮动也是如此</code></p>
</li>
<li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p>
</li>
<li><p>具体事务</p>
<ul>
<li>BFC的区域不会与<code>float box</code>重叠</li>
<li>计算BFC的高度时、浮动元素也参与计算</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠<code>上下margin值穿透</code></li>
</ul>
</li>
</ul>
<h5 id="自适应两列布局"><a href="#自适应两列布局" class="headerlink" title="自适应两列布局"></a>自适应两列布局</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span> &#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.aside</span> &#123;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">background-color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.main</span> &#123;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</div><div class="line">  <span class="attribute">background-color</span>: pink;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">overflow: hidden;会生成浮动</div><div class="line">BFC不会与浮动元素重叠</div><div class="line">实现自适应布局</div><div class="line">*/</div></pre></td></tr></table></figure>
<h5 id="清除内部浮动-overflow-hidden"><a href="#清除内部浮动-overflow-hidden" class="headerlink" title="清除内部浮动(overflow: hidden;)"></a>清除内部浮动(overflow: hidden;)</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 计算BFC的高度时、浮动元素也参与计算 */</span></div><div class="line"><span class="comment">/* 根据这个原理、清除浮动 */</span></div></pre></td></tr></table></figure>
<h5 id="防止垂直margin重叠-一个BFC内的上下margin会重叠"><a href="#防止垂直margin重叠-一个BFC内的上下margin会重叠" class="headerlink" title="防止垂直margin重叠(一个BFC内的上下margin会重叠)"></a>防止垂直margin重叠(一个BFC内的上下margin会重叠)</h5><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/* Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻的Box的margin会发生重叠 */</div><div class="line">&lt;style&gt;</div><div class="line">	p&#123;</div><div class="line">      width: 200px;</div><div class="line">      height: 200px;</div><div class="line">      background-color: red;</div><div class="line">	&#125;</div><div class="line">	.wrap&#123;</div><div class="line">      overflow: hidden;</div><div class="line">	&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;p&gt;111&lt;/p&gt;</div><div class="line">&lt;div class="wrap"&gt;</div><div class="line">  &lt;p&gt;222&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">/*</div><div class="line">在一个重叠的元素上包裹一层容器、并触发该容器生成一个BFC</div><div class="line">两个p标签就不属于同一个BFC、就不会发生重叠</div><div class="line">*/</div></pre></td></tr></table></figure>
<blockquote>
<p>BFC内部的元素和外部的元素”绝对”<strong>不会</strong>相互影响</p>
<ul>
<li>BFC外部存在浮动时、它不应该影响BFC内部Box的布局、BFC会通过变窄、而不与浮动重叠  <strong>两列布局</strong></li>
<li>BFC内部有浮动时、为了不影响外部元素的布局、BFC计算高度时会包括浮动的高度  <strong>清除浮动</strong></li>
<li>BFC内部有重叠发生时、为了不影响外部元素的布局、BFC会包含margin值</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[css居中的几种方案]]></title>
      <url>http://ntscshen.com/2016/08/31/css%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88.html</url>
      <content type="html"><![CDATA[<h4 id="固定宽高"><a href="#固定宽高" class="headerlink" title="固定宽高"></a>固定宽高</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">background-color</span>: red;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;<span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</div><div class="line">  <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">margin</span>: auto;</div><div class="line">  <span class="attribute">background-color</span>: yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.wrap</span> &#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</div><div class="line">  <span class="attribute">background-color</span>: chartreuse;</div><div class="line">  <span class="attribute">display</span>: table;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.wrap</span> <span class="selector-tag">div</span>&#123;</div><div class="line">  <span class="attribute">display</span>: table-cell;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</div><div class="line">  <span class="attribute">background-color</span>: red;</div><div class="line">  <span class="attribute">text-align</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">div</span>&#123;</div><div class="line">  <span class="comment">/* 若为快级元素：则修改为display: inilne-block;即可 */</span></div><div class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">  <span class="attribute">background-color</span>: pink;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::after</span>&#123;</div><div class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">500px</span>;</div><div class="line">    <span class="attribute">background-color</span>: yellow;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="不固定宽度"><a href="#不固定宽度" class="headerlink" title="不固定宽度"></a>不固定宽度</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</div><div class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</div><div class="line">  <span class="attribute">background-color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-class">.div1</span>&#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</div><div class="line">  <span class="attribute">margin</span>: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 相对定位 + 浮动 */</span></div><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">float</span>: left;</div><div class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">background-color</span>: yellow;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">li</span>&#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">left</span>: -<span class="number">50%</span>;</div><div class="line">  <span class="attribute">top</span>: -<span class="number">50%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line">  <span class="attribute">position</span>: absolute;</div><div class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">  <span class="attribute">background-color</span>: red;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.box</span> <span class="selector-tag">li</span>&#123;</div><div class="line">  <span class="attribute">position</span>: relative;</div><div class="line">  <span class="attribute">left</span>: -<span class="number">50%</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  width: 500px;</div><div class="line">  height: 500px;</div><div class="line">  background-color: #77BBDD;</div><div class="line">  /** 各种版本兼容**/</div><div class="line">  display: -webkit-box;</div><div class="line">  display: -moz-box;</div><div class="line">  display: -ms-flexbox;</div><div class="line">  display: -webkit-flex;</div><div class="line">  display: flex;</div><div class="line">  /** 垂直居中核心、兼容**/</div><div class="line">  -webkit-box-pack: center;//09版水平居中</div><div class="line">  -moz-box-pack: center;</div><div class="line">  -ms-flex-pack: center;//过度版(混合版)</div><div class="line">  -webkit-justify-content: center;//12版水平居中</div><div class="line">  justify-content: center;</div><div class="line"></div><div class="line">  -webkit-box-align: center;//09版垂直居中</div><div class="line">  -moz-box-align: center;</div><div class="line">  -ms-flex-align: center;//过度版(混合版)</div><div class="line">  -webkit-align-items: center;//12版垂直居中</div><div class="line">  align-items: center;</div><div class="line">  width: 0%;//低版本Android的flex-item无法等分</div><div class="line">  display: block;</div><div class="line">  /*</div><div class="line">  实则只需三行</div><div class="line">  display: flex;</div><div class="line">  justify-content: center;</div><div class="line">  align-items: center;</div><div class="line">  */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="居中浮动元素"><a href="#居中浮动元素" class="headerlink" title="居中浮动元素"></a>居中浮动元素</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>&#123;</div><div class="line"> 	<span class="attribute">position</span>: relative;</div><div class="line">  	<span class="attribute">left</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">float</span>: left;</div><div class="line">    <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</div><div class="line">    <span class="attribute">margin-top</span>: -<span class="number">100px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line">    <span class="attribute">background-color</span>: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Sass总结]]></title>
      <url>http://ntscshen.com/2016/08/31/Sass%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><blockquote>
<p>痛点：当配置样式时、需要重复修改各种类名的属性、这是是令人恼怒的</p>
<p>解决：类似于JS中的函数封装、哪里用到哪里调用、配置样式只需修改一次</p>
</blockquote>
<ul>
<li>变量定义在规则快之外 - 主样式内容之外</li>
<li>只声明变量其实没啥用处、最终的目的是达到样式可配置</li>
<li>凡是CSS属性的标准值存在的地方、变量都可使用</li>
<li>变量值也可以引用其他变量、通过颗粒度区分、为不同的值取不同的名字、这个规则相当有用</li>
<li><code>$highlight-color: #efe0ce !default;</code>默认值 - 可配置修改、相当于jQuery的$.extend({},this.defaults,opt),this.defaults = {‘color’:’red’},</li>
<li>变量名可以命名为属性名OR选择器名称、中划线和下划线可以相互混用</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$highlight-color</span>: <span class="number">#efe0ce</span>;</div><div class="line"><span class="variable">$highlight-border</span>: <span class="number">1px</span> solid <span class="variable">$hightlight-color</span>;</div><div class="line"><span class="selector-class">.selected</span>&#123;</div><div class="line">  <span class="attribute">border</span>: <span class="variable">$highlight-border</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 编译</span></div><div class="line"><span class="selector-class">.selected</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#efe0ce</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="文件导入"><a href="#文件导入" class="headerlink" title="文件导入"></a>文件导入</h2><p><code>.blue{@import &quot;blue-theme&quot;}</code></p>
<p>不能用<code>sass</code>的<code>@import</code>直接导入一个原始的<code>css</code>文件，因为<code>sass</code>会认为你想用<code>css</code>原生的<code>@import</code>。但是，因为<code>sass</code>的语法完全兼容<code>css</code>，所以你可以把原始的<code>css</code>文件改名为<code>.scss</code>后缀，即可直接导入了。</p>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><blockquote>
<p>痛点：css中重复写选择器是令人恼怒的、为了样式的不冲突需要一遍遍的写相同的<code>ID</code></p>
<p>解决：sass的嵌套写法、只需写一遍、且可读性大大提高</p>
</blockquote>
<ul>
<li>在sass书写中会配到使用伪类元素情况<code>:hover</code> <code>:after</code> <code>nth-child</code>使用常规的嵌套方案会出现问题</li>
<li>正常的嵌套解耦是通过一个空格链接到子选择器的前面<code>后代选择器</code></li>
<li>使用父选择器标示符<code>&amp;</code></li>
<li>子组合选择器和同层组合选择器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">article&#123;</div><div class="line">  ~ article&#123;border-top: 1px dashed #ccc;&#125;</div><div class="line">  &gt; section &#123;background-color: #eee;&#125;</div><div class="line">  dl &gt; &#123;</div><div class="line">    dt&#123;color: #333;&#125;</div><div class="line">    dd&#123;color: #555;&#125;</div><div class="line">  &#125;</div><div class="line">  nav + &amp; &#123;margin-top: 0;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>属性嵌套</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">nav</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span> &#123;</div><div class="line">    left: <span class="number">1px</span>;</div><div class="line">    <span class="attribute">right</span>: <span class="number">1px</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">nav</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</div><div class="line">  <span class="attribute">border-left</span>: <span class="number">1px</span>;</div><div class="line">  <span class="attribute">border-right</span>: <span class="number">1px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="sass的条理性和可读性基础：变量、嵌套、导入、注释"><a href="#sass的条理性和可读性基础：变量、嵌套、导入、注释" class="headerlink" title="sass的条理性和可读性基础：变量、嵌套、导入、注释"></a>sass的条理性和可读性基础：变量、嵌套、导入、注释</h4></blockquote>
<h2 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h2><blockquote>
<p>痛点：整个网站中有几处小小的样式类似（例如一致的颜色和字体），那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。</p>
</blockquote>
<p>通过<code>@mixin example</code>标示符定义、然后使用 <code>@include example</code>调用</p>
<p>大多数情况<code>@extend</code>可以满足日常的开发需求</p>
<p>而@include、较少使用的到<code>e.g. 计算rem和px的装换</code></p>
<p>至于css3的前缀问题可以使用<code>Autoprefixer</code>插件在构建完成后自动添加</p>
<p><img src="http://occeqxmsk.bkt.clouddn.com/2016-08-31_include%E5%92%8Cextend%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt="include和extend的区别"></p>
<blockquote>
<p>@include和@extend的区别</p>
<ul>
<li>@include是用来调用@mixin的定义(包括)</li>
<li>@extend(延伸)<ul>
<li>继承选择器的样式</li>
<li>继承一个定义好的<code>placeholder</code></li>
</ul>
</li>
<li>相同之处：都可以給选择器添加一系列属性、而不用重复手写</li>
<li>不同之处：<ul>
<li><code>@extend会</code>合并选择器、共享属性</li>
<li><code>@mixin</code>每个选择器是独立存在的</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="修改伪元素"><a href="#修改伪元素" class="headerlink" title="修改伪元素"></a>修改伪元素</h2><blockquote>
<p>修改伪元素的content的属性值</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// CSS代码</div><div class="line">.red::before &#123;</div><div class="line">    content: attr(data-attr);</div><div class="line">    color: red;</div><div class="line">&#125;</div><div class="line">// HTML代码</div><div class="line">&lt;div class="red" data-attr="red"&gt;内容内容内容内容&lt;/div&gt;</div><div class="line"></div><div class="line">// JacaScript代码</div><div class="line">$('.red').attr('data-attr', 'green');</div></pre></td></tr></table></figure>
<blockquote>
<p>更改伪元素的样式1</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// CSS代码</div><div class="line">.red::after&#123;</div><div class="line">  content:"red",</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line">.green::after&#123;</div><div class="line">  content:"green",</div><div class="line">  color: green;</div><div class="line">&#125;</div><div class="line">// HTML代码</div><div class="line">&lt;div class="red"&gt;内容内容内容&lt;/div&gt;</div><div class="line">// jQuery代码</div><div class="line">$(".red").removeClass("red").addClass("green");</div></pre></td></tr></table></figure>
<blockquote>
<p>更改伪元素的样式2</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].addRule(<span class="string">'.red::before'</span>,<span class="string">'color: green'</span>); <span class="comment">// 支持IE </span></div><div class="line"><span class="built_in">document</span>.styleSheets[<span class="number">0</span>].insertRule(<span class="string">'.red::before &#123; color: green &#125;'</span>, <span class="number">0</span>); </div><div class="line"><span class="comment">// 支持非IE的现代浏览器</span></div><div class="line"><span class="comment">// styleSheets:返回由网页中所用到的样式表组成的数组，但是不包括直接嵌在元素里的style。</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'&lt;style&gt;.red::before&#123;color:green&#125;&lt;/style&gt;'</span>).appendTo(<span class="string">'head'</span>);</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[css如何居中一个浮动元素]]></title>
      <url>http://ntscshen.com/2016/08/30/%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%ADdiv%EF%BC%9F%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0.html</url>
      <content type="html"><![CDATA[<h2 id="如何利用CSS居中一个浮动元素"><a href="#如何利用CSS居中一个浮动元素" class="headerlink" title="如何利用CSS居中一个浮动元素"></a>如何利用CSS居中一个浮动元素</h2><blockquote>
<ul>
<li>居中一个浮动元素 <strong>宽度是必须的</strong> </li>
<li>使用相对定位</li>
<li>使用margin</li>
</ul>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">  	position: relative;//相对于父级</div><div class="line">  	left: 50%;</div><div class="line">	top: 50%;</div><div class="line">	float: left;</div><div class="line">  	margin-left: -100px;</div><div class="line">  	margin-top: -100px;</div><div class="line">  	width: 200px;</div><div class="line">  	height: 200px;</div><div class="line">  	background-color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="如何居中div"><a href="#如何居中div" class="headerlink" title="如何居中div"></a>如何居中div</h2><h2 id="css中可以被继承的属性"><a href="#css中可以被继承的属性" class="headerlink" title="css中可以被继承的属性"></a>css中可以被继承的属性</h2><p><code>font-size、font-family、font-size、font-weight、color、text-indent、line-height、text-align、letter-spacing、word-spacing</code></p>
<ul>
<li>文本相关属性<ul>
<li><code>font-size、font-style、font-family、font-weight、font、</code></li>
<li><code>line-height、text-align、</code></li>
<li><code>text-indent首行文本缩进、letter-spacing单个字母间距、word-spacing以空白为分割间距</code></li>
</ul>
</li>
<li>列表相关属性(li)<ul>
<li><code>list-style-type: decimal数字、circle空心圆、默认实心圆</code></li>
<li><code>list-style-position:inside放在文本以内且环绕文本 outside默认</code></li>
<li><code>list-style-image:使用图像来替换列表项的标记</code></li>
<li><code>缩写形式:list-style: decimal outside url(&#39;img/arror.gif&#39;);</code></li>
</ul>
</li>
<li>颜色<code>color</code></li>
<li>若被问到类似的问题<ul>
<li>字体系列<code>font-size\font-family\font-style\font-weight</code></li>
<li>字体颜色<code>color</code></li>
<li>字体间距<code>letter-spacing\word-spacing</code></li>
<li>列表系列<code>list-style-image\type\position</code></li>
<li><code>line-height\text-align\text-indent</code></li>
</ul>
</li>
</ul>
<h2 id="css中的选择器"><a href="#css中的选择器" class="headerlink" title="css中的选择器"></a>css中的选择器</h2><ul>
<li>常规选择器：ID\class\元素\ *通配符</li>
<li>伪类选择器：<ul>
<li>动态伪类选择器<code>:link\:visited\:active\:hover\:focus</code></li>
<li>状态伪类选择器<ul>
<li><code>E:disabled{}</code>匹配所有被禁言的表单元素</li>
<li><code>E:checked{}</code>匹配表单中被选中的单选或复选按钮</li>
<li><code>E:enabled{}</code>匹配被启用的元素(表单元素)checked反面</li>
</ul>
</li>
<li>结构伪类<ul>
<li><code>E:first-child</code>选取特定元素的第一个子元素 OR <code>last-child</code></li>
<li><code>E:first-of-type(){}</code> 和first-child一样、只是指定了元素类型</li>
<li><code>E:nth-child(n)</code>选取特定元素的一个或多个子元素、n虫1开始、也可以是odd(奇数)，even(偶数)。<code>E:nth-last-child(n)</code></li>
<li><code>E:nth-of-type(n){}</code>计算父元素中指定的<code>某种类型的</code>子元素</li>
<li><code>E:root</code>匹配E所在文档的跟元素</li>
<li><code>E::first-line</code>匹配元素的第一行文本、常用于文本排版</li>
<li><code>E::after</code> <code>E::before</code></li>
<li><code>::selection</code>选中的文本背景颜色</li>
</ul>
</li>
</ul>
</li>
<li>关系选择器：<ul>
<li>A &gt; E 直系后代(children)<code>子代选择器</code></li>
<li>A E 后代元素(find)<code>后代选择器</code></li>
<li>E + F 同辈元素且在E后面的元素(next)<code>相邻兄弟元素选择器</code></li>
</ul>
</li>
</ul>
<h2 id="样式的优先级算法-优先级"><a href="#样式的优先级算法-优先级" class="headerlink" title="样式的优先级算法 - 优先级"></a>样式的优先级算法 - <strong>优先级</strong></h2><ul>
<li>内联</li>
<li>ID选择器</li>
<li>伪类选择器<code>e.g: E:first-child{}</code></li>
<li>属性选择器<code>e.g: input[type=&quot;text&quot;]{}</code></li>
<li>类选择器</li>
<li>元素选择器</li>
<li>通配符</li>
<li><code>!important</code>除外</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[css如何居中一个浮动元素]]></title>
      <url>http://ntscshen.com/2016/08/30/%E6%AF%8F%E6%97%A5ES6%20-%20let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="html"><![CDATA[<h2 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a><strong>let和var的区别</strong></h2><ul>
<li>块级作用域：用let定义的变量只在定义它的块中有效</li>
<li>不会变量提升、为声明前使用、直接报错。</li>
<li>let会暂时性死区、一但快内let声明了a、全局变量a将不会起作用</li>
<li>let不允许在相同作用域内、重复声明同一个变量<blockquote>
<p>为什么引进块级作用域？<br>for循环的i变量控制循环、防止泄露<br>在ES6之前 - JS没有块级作用域</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// function要注意的规范</span></div><div class="line"><span class="comment">// 应该避免在块级作用域内声明函数、如果确实需要、也应该写成函数表达式、而不是函数式声明</span></div><div class="line"><span class="comment">// 函数式声明</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="string">"shen"</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 函数表达式</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="string">"yang"</span>;</div><div class="line">  <span class="keyword">let</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> a;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[抓包工具]]></title>
      <url>http://ntscshen.com/2016/08/22/%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7.html</url>
      <content type="html"><![CDATA[<h2 id="抓包工具"><a href="#抓包工具" class="headerlink" title="抓包工具"></a>抓包工具</h2><p><a href="http://www.imooc.com/view/37" target="_blank" rel="external">Win上的抓包 - Fiddler工具使用</a> </p>
<p><a href="https://item.taobao.com/item.htm?spm=a1z10.4-c.w4004-11940565164.17.FWVVGt&amp;id=535920069637" target="_blank" rel="external">Mac上的抓包 - Charles正版购买</a></p>
<p><a href="http://itangqi.me/2016/05/30/tips-for-using-charles/" target="_blank" rel="external">Qi Tang’s Blog站的Charles使用心得</a></p>
<blockquote>
<p>使用Charles、记录安装和使用</p>
</blockquote>
<h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><blockquote>
<p>打开VPN之后、Charles将不会工作、因此撤掉VPN</p>
</blockquote>
<h3 id="设置端口并开启代理"><a href="#设置端口并开启代理" class="headerlink" title="设置端口并开启代理"></a>设置端口并开启代理</h3><p><img src="http://ww3.sinaimg.cn/mw690/9c0ebacdjw1f2bd8cgrjsj20kb0frq4d.jpg" alt="端口"></p>
<p>确定工具栏下的 Proxy-&gt;Mac OS X Proxy被勾选上了</p>
<h3 id="安装SSL证书"><a href="#安装SSL证书" class="headerlink" title="安装SSL证书"></a>安装SSL证书</h3><p><img src="http://blog.devtang.com/images/charles-pro-1.png" alt="SSL证书"></p>
<p><img src="https://gitsea.com/wp-content/uploads/2015/11/D13318CA-78BE-47E7-8D82-93B7630DD700.jpg" alt="SSL证书"></p>
<h2 id="手机设置"><a href="#手机设置" class="headerlink" title="手机设置"></a>手机设置</h2><p>手机端和电脑链接在一个网段内，设置HTTP代理</p>
<p><img src="https://gitsea.com/wp-content/uploads/2015/11/7B30A925-1817-4968-BEEE-052EAB0E21DC-352x600.jpg" alt="手机设置代理"></p>
<p>然后打开手机浏览器，输入 <a href="http://www.charlesproxy.com/getssl/进行mac电脑charles" target="_blank" rel="external">http://www.charlesproxy.com/getssl/进行mac电脑charles</a> ssl 根证书安装</p>
<p><img src="https://gitsea.com/wp-content/uploads/2015/11/51BB8CA2FEEC517BB75CEBCFA2B171C7-337x600.png" alt="手机证书安装"></p>
<p>安装成功之后不管是手机内部app还是浏览器浏览https 站点，都可以进行抓包</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SSH Key到Github]]></title>
      <url>http://ntscshen.com/2016/08/18/%E6%B7%BB%E5%8A%A0SSH%20Key%E5%88%B0Github.html</url>
      <content type="html"><![CDATA[<h2 id="添加ssh-key到Github"><a href="#添加ssh-key到Github" class="headerlink" title="添加ssh key到Github"></a>添加ssh key到Github</h2><p>首先先确认是否已经存在公钥了( SSH Keys )</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls -al ~<span class="regexp">/.ssh</span></div></pre></td></tr></table></figure>
<ul>
<li>若存在<code>id_rsa</code>或<code>id_rsa.pub</code>。则代表已经生成过Key值、直接将SSH key添加到Github中</li>
</ul>
<h2 id="生成SSH-公钥"><a href="#生成SSH-公钥" class="headerlink" title="生成SSH 公钥"></a>生成SSH 公钥</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C <span class="string">"注释内容，一般为邮件地址 xxx@163.com"</span></div></pre></td></tr></table></figure>
<p>接着会显示以下的输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file in which to save the key (/Users/eguchi/.ssh/id_rsa): # &lt;输入Enter键&gt;</div><div class="line">Created directory '/Users/eguchi/.ssh'.</div><div class="line">Enter passphrase (empty for no passphrase): # &lt;输入验证密码&gt;</div><div class="line">Enter same passphrase again: # &lt;再输入一次相同的验证密码&gt;</div><div class="line">Your identification has been saved in /Users/eguchi/.ssh/id_rsa.</div><div class="line">Your public key has been saved in /Users/eguchi/.ssh/id_rsa.pub.</div><div class="line">The key fingerprint is:</div><div class="line">57:15:3c:ca:f2:dc:27:6d:c2:9a:88:d0:70:cf:8d:31 xxx@163.com</div><div class="line">The key's randomart image is:</div><div class="line">+--[ RSA 2048]----+</div><div class="line">|             .o. |</div><div class="line">|             .o  |</div><div class="line">|           ... . |</div><div class="line">|      . . E.o    |</div><div class="line">|       +So.O o . |</div><div class="line">|      . ..+ + = +|</div><div class="line">|       . . . o = |</div><div class="line">|        . . o    |</div><div class="line">|                 |</div><div class="line">+-----------------+</div></pre></td></tr></table></figure>
<p>默认会在相应路径下<code>~/.ssh</code>生成<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件</p>
<p>复制id_rsa.pub文件信息<code>cat ~/.ssh/id_rsa.pub</code>。将这些信息复制到Github的Add SSH key页面。</p>
<p>输出实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDkkJvxyDVh9a+zH1f7ZQq/JEI79dVjDSG</div><div class="line"><span class="number">4</span>RzttQwfK+sgWEr0aAgfnxdxQeDKxIxqI1SwyTY8oCcWzvpORuPqwbc7UWWPcCvbQ3jlEdN</div><div class="line"><span class="number">5</span>jvwKM82hincEWwI3wzcnVg2Mn8dH86b5m6REDzwRgozQ3lqrgwGVlTvkHDFs6H0b/<span class="number">1</span>PSrM</div><div class="line">XGppOP/QXGEVhZ6Hy4m3b1wMjjrbYwmWIeYklgoGHyrldhAaDYc33y7aUcRyFyq5DubtsLn</div><div class="line"><span class="number">2</span>oj4K+<span class="number">1</span>q36iviCHxCOri0FDmn2dzylRCI4S+A2/P7Y7rVfdT+<span class="number">8</span>OWYKCBUs8lfjujghEtejq</div><div class="line">Qmj9ikyGTEAW1zQCN7hVwYdjL xxx@<span class="number">163.</span>com</div></pre></td></tr></table></figure>
<p>进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p>
<p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方<code>Add key</code>绿色按钮即可。</p>
<h2 id="不同的操作系统，均有一些命令，直接将SSH-key从文件拷贝到粘贴板中，如下："><a href="#不同的操作系统，均有一些命令，直接将SSH-key从文件拷贝到粘贴板中，如下：" class="headerlink" title="不同的操作系统，均有一些命令，直接将SSH key从文件拷贝到粘贴板中，如下："></a>不同的操作系统，均有一些命令，直接将SSH key从文件拷贝到粘贴板中，如下：</h2><p><strong>mac</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pbcopy &lt; ~/.ssh/id_rsa.pub</div><div class="line"># Copies the contents of the id_rsa.pub file to your clipboard</div></pre></td></tr></table></figure>
<p><strong>windows</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">clip &lt; ~/.ssh/id_rsa.pub</div><div class="line"># Copies the contents of the id_rsa.pub file to your clipboard</div></pre></td></tr></table></figure>
<p><strong>linux</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install xclip</div><div class="line"># Downloads and installs xclip. If you don&apos;t have `apt-get`, you might need to use another installer (like `yum`)</div><div class="line"></div><div class="line">xclip -sel clip &lt; ~/.ssh/id_rsa.pub</div><div class="line"># Copies the contents of the id_rsa.pub file to your clipboard</div></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure>
<p>超时报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh: connect to host github.com port 22: Operation timed out</div></pre></td></tr></table></figure>
<p>让SSH走443端口<a href="https://help.github.com/articles/using-ssh-over-the-https-port/" target="_blank" rel="external">解决方案</a></p>
<p>编辑<code>~/.ssh/config</code>文件(若没有、则创建一个)<code>touch config</code></p>
<p><code>vim config</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Host github.com</div><div class="line">User ntscshen@163.com</div><div class="line">Hostname ssh.github.com</div><div class="line">PreferredAuthentications publickey</div><div class="line">IdentityFile ~/.ssh/id_rsa</div><div class="line">Port 443</div><div class="line"></div><div class="line">Host gi.coding.net</div><div class="line">User ntscshen@163.com</div><div class="line">Hostname ssh.github.com</div><div class="line">PreferredAuthentications publickey</div><div class="line">IdentityFile ~/.ssh/id_rsa</div><div class="line">Port 443</div><div class="line"></div><div class="line">Host，SSH 连接名</div><div class="line">HostName，如上所示，可以是通配符，可以是 IP，也可以是域名等</div><div class="line">User，登录的用户名</div><div class="line">IdentifyFile，</div><div class="line">	version 1 协议下默认是 ~/.ssh/identify，</div><div class="line">	version 2 协议下，默认是依次匹配：~/.ssh/id_dsa，~/.ssh/id_ecdsa，~/.ssh/id_rsa，</div><div class="line">	还有 version 2 兼容模式。</div><div class="line">LocalForward 端口的内部跳转</div><div class="line">Port，端口设置，默认 SSH 的端口是 22 // 公司封github 22端口</div><div class="line">Protocal，协议版本号，1 或者 2</div></pre></td></tr></table></figure>
<p><code>:wq</code></p>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ol>
<li>ssh-keygen 用于为 ssh(1)生成、管理和转换认证密钥，包括 RSA 和 DSA 两种密钥。</li>
<li>密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。</li>
<li>-t type - 指定要创建的密钥类型。可以使用：”rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2)</li>
<li>-C comment - 提供一个新注释</li>
</ol>
]]></content>
    </entry>
    
  
  
</search>
