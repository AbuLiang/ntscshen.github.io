<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[设计模式-代理模式(3)]]></title>
      <url>%2F2017%2F02%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F(3).html</url>
      <content type="text"><![CDATA[代理模式( Proxy )：由于一个对象不能直接引用另外一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用 虚拟代理和缓存代理 图片预加载 12345678910111213141516// 没有使用代理的图片预加载var MyImage = (function()&#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); var img = new Image; img.onload = function()&#123; imgNode.src = img.src; &#125; return &#123; setSrc: function(src)&#123; imgNode.src = 'loading.gif'; img.src = src; &#125; &#125;&#125;)();MyImage.setSrc('image.png'); 1234567891011121314151617181920212223// 使用代理的图片预加载 - 虚拟代理var myImage = (function()&#123; var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return &#123; setSrc: function(src)&#123; imgNode.src = src; &#125; &#125;;&#125;)();var proxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src)&#123; myImage.setSrc('loading.gif'); img.src = src; &#125; &#125;&#125;)();proxyImage.setSrc('image.png'); 代理和本体接口的一致性 代理和本体接口的一致性(代理接手请求的过程对于用户来说是透明的) 1、用户可以放心的请求代理，他只关心是否能得到想要的结果。 2、在任何使用本地的地方都可以替换成使用代理 缓存代理123456789101112131415161718192021// 乘积函数var mult = function()&#123; var a = 1; for(var i = 0, len = arguments.length; i &lt; len; i++)&#123; a = a * arguments[i]; &#125; return a;&#125;// 加入缓存代理var proxMult = (function()&#123; var cache = &#123;&#125;; return function()&#123; var args = Array.prototype.join.call(arguments,','); if(args in cache)&#123; return cache[args]; &#125; return cache[args] = mult.apply(this, arguments); &#125;&#125;)();proxMult(1,2,3,4,5);proxMult(1,2,3,4,5); 使用代理的意义 使用代理的意义 单一职责原则：一个类(通常包括对象和函数等)而言，应该仅有一个引起它变化的原因。如果对象承担了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。 面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象承担的职责过多，等于把这些职责耦合到一起，这种耦合会导致脆弱和低内聚的设计。当变化发生时，设计可能会遭到意外的破坏。 在面向对象的程序设计中，大多数情况下，若违反其他任何原则，同时将违反开放 - 封闭原则。如果五年后网速快到根本不需要预加载技术，我们可能希望把预加载图片的这段代码从MyImage对象里删掉，这个时候就不得不改动MyIage对象了。 在JavaScript开发中最常用的是虚拟代理和缓存代理。虽然代理模式非常有用，但我们在编写业务代码的时候，往往不需要去预先猜测是否需要使用代理模式。当真正发现不方便访问某个对象的时候，再编写代理也不迟。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ESLint检查代码质量]]></title>
      <url>%2F2017%2F02%2F16%2FESLint%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F.html</url>
      <content type="text"><![CDATA[从接触js开始就想尝试ESLint， 但是一执行检查满屏的Error、惨绝人寰(a、a、a)、后放弃 为什么会有如此多的Error： 刚开始接触 ESLint 时觉得太难，是因为过太过于迷信权威。比如 Airbnb 公司的 JavaScript 风格，在 GitHub 上受到了很大的好评，其实我自己也非常认可这样的编码风格。但每个团队都会根据自己的的实际情况来定制不同的东西，我们并不能随便照搬过来。所以当使用eslint-config-airbnb这个配置进行 ESLint 检查时，满屏都是error和warning，从而觉得这东西根本没啥卵用。 直接使用eslint-config-airbnb这种某个公司高度定制化的配置直接使用eslint-config-airbnb这种某个公司高度定制化的配置，而不是eslint:recommended这样保守的。而且是直接用来检查整个项目好几十个 JS 文件，可想而知那是怎样的画面 ESLint是一个插件化的 JavaScript 代码检查工具，用于检查常见的 JS代码错误，也可以进行代码风格检查，可以根据自己的洗好指定一套ESLint配置项，让后应用于所编写的项目中，从而实现 辅助编码规范的执行，有效控制代码的质量 使用ESLint 通过npm安装： npm install -g eslint 通过 eslint —init 命令在当前目录下生成 .eslintrc.* 文件。如果没有 package.json文件的话，需要先创建一个这个文件，eslint会根据你的安装向导写入对应的插件到 devDependencies 里面 12"dependencies": &#123;&#125;,//生产环境"devDependencies": &#123;&#125;//开发环境 配置ESLint 通过配置文件： .eslingrc.* 或 package.json 中添加 eslintConfig 属性 配置的内容 环境：代码运行的环境，每个环境与预设了一些全局变量 全局变量：代码所运用到的全局变量 规则：规则的运用以及规则的等级 规则每条规则有3个等级： off、warn 、error off( 0 )：禁用这条规则 warn( 1 )：表示仅给出警告、并不会导致检查不通过 error( 2 )：错误、检查不通过 如果配置了 &quot;extends&quot;:&quot;eslint:recommended&quot;, 则 ESLint Rules页面 所有打钩的规则都会被生效（ 基础配置信息 ）。大多数时候，我们会根据自己个人或者团队的习惯，定制更多的规则，( 限定缩进2个空格和实用单引号的字符串等等 ) 可以写一套自己的配置项发布到NPM上的ESLint配置 模块名一般以 eslint-config- 为前缀。要是用这个配置，先止一下命令安装它： npm install eslint-config-shen 指定Parser的选项ESLint默认只支持ES5的语法，但你可以通过指定parser来支持检测ES6和JSX语法。具体是在 .eslintrc.* 文件中使用 parserOptions 属性。可以设置如下内容 ecmaVersion：可以设置3，5（默认）和6来代表ECMAScript的版本 sourceType：可以设置“script”（默认）或”module”如果你的代码采用模块化的方式 ecmaFeatures：设置features：globalReturn：在全局范围内允许使用return语句impliedStrict：如果ecmaVersion为5及以上，使用全局的 strict modejsx：使用JSX语法experimentalObjectRestSpread Parser：语法分析器。options：选择 指定环境 amd：定义 require() 和 define() 作为全局变量 12345"env": &#123; "browser": true, "node": true, 'jquery': true&#125;, 配置插件ESLint支持第三方插件的使用，在使用插件前需要通过npm来安装。在配置文件中使用plugins来设置插件名称。带有eslint-plugin-前缀的插件名称可以省略其前缀。如 123456&#123; "plugins": [ "plugin1", "eslint-plugin-plugin2" ]&#125; 注意：如果是使用的全局安装的ESLint的话，则只能使用全局安装的ESlint插件。而使用本地安装的ESLint则可以使用全局和本地安装的ESLint插件。 使用配置文件通过 .eslintrc.* 或 .eslintrc.json 文件方式，ESLint会自动寻找当前目录下的这两个文件，如果没有就想父级目录寻找，直到查询到根目录。这种方式比较有用，特别是需要针对不同的部分应用不同的规则。最里面的配置规则要比它的父级权限大。 ESLint支持如下几种格式的配置文件： JavaScript：使用 .eslintrc.js,通过exports一个包含所有规则的对象 JSON：使用 .eslintrc.json 来配置规则 package.json：在 package.json 中定义 eslintConfig 来设置规则 YAML Deprecated 如果当前目录下有多个配置格式的文件，则ESLint只会使用其中一个，顺序为： .eslintrc.js &gt; .eslintrc.yaml &gt; .eslintrc.yml &gt; .eslintrc.json &gt; .eslintrc &gt; package.json 默认情况下，我们不需要应用跨项目的配置规则，即使项目在目录上有父子关系，此时我们可以通过在 package.json 的 eslintConfig 或 .eslintrc.* 中设置 &quot;root&quot;: true 来静止ESLint继续想上级查找配置文件 123&#123; "root": true&#125; 项目级别的配置 目录下的 .eslintrc.* 或 package.json 继续在父级目录中查找的 .eslintrc 和 package.json 文件，直到出现 &quot;root&quot;: true 如果前两个都没有配置文件的话，就会用用户根目录下的 ~/.eslintrc 继承配置文件 如果你想继承某个特定的配置文件，可以使用 extends 属性，并且制定一个路径，可以是相对或绝对路径。可以继承多个文件，写在下面的配置规则会覆盖上面配置中对应的规则。 12345678910module.exports = &#123; "extends": [ "eslint":"recommended", "./node_modules/coding-standard/.eslintrc-es6" ], "rules": &#123; 'no-var': 'off', 'no-console': 'off' &#125;&#125;; 配置文件中的注释JSON和YAML配置文件都支持JavaScript格式注释， package.json 不支持注释 代码格式化、自动修复一些问题eslint test.js --fix 发布一个ESLint NPM管理包。。。 123456789101112131415161718192021222324module.exports = &#123; "root": true, "env": &#123; 'browser': true, 'es6': true, 'node': true, 'jquery': true &#125;, "extends": "eslint:recommended", "rules": &#123; 'no-var': 'off', 'no-console': 'off', // "indent": [ // "error", "tab" // ], // "linebreak-style": [ // "error", "unix" // ], // "quotes": [ // "error", "single" // ], // "semi": ["error", "always"] &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533module.exports = &#123; // 禁止ESLint继续向上级查找配置文件 "root": true, // 环境：预定以的全局变量 "env": &#123; 'browser': true, 'es6': true, 'node': true, 'jquery': true, 'amd': true, 'commonjs': true &#125;, // JavaScript 语言选项 "parserOptions": &#123; // ECMAScript 版本 "ecmaVersion": 6, "sourceType": "script", //module &#125;, "extends": "eslint:recommended", "rules": &#123; //////////////// // 警告 //////////////// // 强制使用有效的 JSDoc 注释 "valid-jsdoc": 1, // 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号， // always-multiline：多行模式必须带逗号，单行模式不能带逗号 "comma-dangle": [ 1, "never" ], // 禁止或强制在单行代码块中使用空格(禁用) "block-spacing": [ 1, "never" ], // 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了 // e.g [0,"that"] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值 "consistent-this": [ 1, "that" ], // 强制使用一致的换行风格 "linebreak-style": [ 1, "unix" ], // 要求在注释周围有空行 ( 要求在块级注释之前有一空行) "lines-around-comment": [ 1, &#123; "beforeBlockComment": true &#125; ], // 强制 function 定义中最多允许的参数数量 "max-params": [ 1, 7 ], // 强制 function 块最多允许的的语句数量 "max-statements": [ 1, 200 ], // 要求方法链中每个调用都有一个换行符 "newline-per-chained-call": 1, // 要求使用 JSDoc 注释 "require-jsdoc": 1, // 强制一行的最大长度 "max-len": [ 1, 200 ], // 禁止在没有类型检查操作符的情况下与 null 进行比较 "no-eq-null": 1, // 禁止在全局范围内使用 var 和命名的 function 声明 "no-implicit-globals": 1, // 禁止在循环中出现 function 声明和表达式 "no-loop-func": 1, // 禁用魔术数字(3.14什么的用常量代替) "no-magic-numbers": [ 1, &#123; "ignore": [0, -1, 1] &#125; ], //////////////// // 禁止 //////////////// // 禁用 console "no-console": 0, // 禁止不必要的括号 //(a * b) + c;//报错 "no-extra-parens": 0, // 禁止直接使用 Object.prototypes 的内置属性 "no-prototype-builtins": 0, // 强制数组方法的回调函数中有 return 语句 "array-callback-return": 0, // 强制把变量的使用限制在其定义的作用域范围内 "block-scoped-var": 0, // 要求 return 语句要么总是指定返回的值，要么不指定 "consistent-return": 0, // 禁用 alert、confirm 和 prompt "no-alert": 0, // 禁止 if 语句中有 return 之后有 else "no-else-return": 0, // 禁用不必要的标签 "no-extra-label:": 0, // 禁止 this 关键字出现在类和类对象之外 "no-invalid-this": 0, // 禁止对 Function 对象使用 new 操作符 "no-new-func": 0, // 不允许对 function 的参数进行重新赋值 "no-param-reassign": 0, // 禁止使用短符号进行类型转换(!!fOO) "no-implicit-coercion": 0, // 禁用指定的通过 require 加载的模块 "no-return-assign": 0, // 禁止使用 javascript: url "no-script-url": 0, // 禁止出现未使用过的表达式 "no-unused-expressions": 0, // 禁用不必要的转义字符 "no-useless-escape": 0, // 禁用 void 操作符 "no-void": 0, // 禁止在注释中使用特定的警告术语 "no-warning-comments": 0, // 要求或禁止使用严格模式指令 "strict": 0, // 要求所有的 var 声明出现在它们所在的作用域顶部 "vars-on-top": 0, // 强制使用命名的 function 表达式 "func-names": 0, // 禁止使用指定的标识符 "id-blacklist": 0, // 强制标识符的最新和最大长度 "id-length": 0, // 要求标识符匹配一个指定的正则表达式 "id-match": 0, // 强制在 JSX 属性中一致地使用双引号或单引号 "jsx-quotes": 0, // 要求或禁止 var 声明中的初始化(初值) "init-declarations": 0, // 不允许 catch 子句的参数与外层作用域中的变量同名 "no-catch-shadow": 0, // 禁用特定的全局变量 "no-restricted-globals": 0, // 禁止 var 声明 与外层作用域的变量同名 "no-shadow": 0, // 禁止将 undefined 作为标识符 "no-undefined": 0, // 强制一致地使用函数声明或函数表达式，方法定义风格，参数： // declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, "declaration"] // expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, "expression"] // allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, "declaration", &#123; "allowArrowFunctions": true &#125;] "func-style": 0, // 强制最大行数 "max-lines": 0, // 强制每一行中所允许的最大语句数量 "max-statements-per-line": 0, // 禁用按位运算符 "no-bitwise": 0, // 不允许在变量定义之前使用它们 "no-use-before-define": 0, // 要求或禁止 var 声明语句后有一行空行 "newline-after-var": 0, // 要求 return 语句之前有一空行 "newline-before-return": 0, // 禁用 continue 语句 "no-continue": 0, // 禁止在代码行后使用内联注释 "no-inline-comments": 0, // 禁止 if 作为唯一的语句出现在 else 语句中 "no-lonely-if": 0, // 禁止混合使用不同的操作符 "no-mixed-operators": 0, // 不允许使用三元操作符 "no-ternary": 0, // 禁止使用特定的语法 "no-restricted-syntax": 0, // 禁止标识符中有悬空下划线_bar "no-underscore-dangle": 0, // 不允许否定的表达式 "no-negated-condition": 0, // 不允许使用嵌套的三元表达式 "no-nested-ternary": 0, // 禁止使用一元操作符 ++ 和 -- "no-plusplus": 0, // 要求或禁止在 var 声明周围换行 "one-var-declaration-per-line": 0, // 要求或禁止在可能的情况下要求使用简化的赋值操作符 "operator-assignment": 0, // 禁止属性前有空白 "no-whitespace-before-property": 0, // 强制花括号内换行符的一致性 "object-curly-newline": 0, // 强制在花括号中使用一致的空格 "object-curly-spacing": 0, // 强制将对象的属性放在不同的行上 "object-property-newline": 0, // 要求或禁止块内填充 "padded-blocks": 0, // 要求对象字面量属性名称用引号括起来 "quote-props": 0, // 强制分号之前和之后使用一致的空格 "semi-spacing": 0, // 要求同一个声明块中的变量按顺序排列 "sort-vars": 0, // 要求或禁止 Unicode BOM "unicode-bom": 0, // 要求正则表达式被括号括起来 "wrap-regex": 0, //////////////// // 错误 //////////////// // 禁止条件表达式中出现赋值操作符 "no-cond-assign": 2, // 禁止在条件中使用常量表达式 // if (false) &#123; // doSomethingUnfinished(); // &#125; //cuowu "no-constant-condition": 2, // 禁止在正则表达式中使用控制字符 ：new RegExp("\x1f") "no-control-regex": 2, // 禁用 debugger "no-debugger": 2, // 禁止 function 定义中出现重名参数 "no-dupe-args": 2, // 禁止对象字面量中出现重复的 key "no-dupe-keys": 2, // 禁止重复的 case 标签 "no-duplicate-case": 2, // 禁止空语句块 "no-empty": 2, // 禁止在正则表达式中使用空字符集 (/^abc[]/) "no-empty-character-class": 2, // 禁止对 catch 子句的参数重新赋值 "no-ex-assign": 2, // 禁止不必要的布尔转换 "no-extra-boolean-cast": 2, // 禁止不必要的分号 "no-extra-semi": 2, // 禁止对 function 声明重新赋值 "no-func-assign": 2, // 禁止在嵌套的块中出现 function 或 var 声明 "no-inner-declarations": [ 2, "functions" ], // 禁止 RegExp 构造函数中无效的正则表达式字符串 "no-invalid-regexp": 2, // 禁止在字符串和注释之外不规则的空白 "no-irregular-whitespace": 2, // 禁止在 in 表达式中出现否定的左操作数 "no-negated-in-lhs": 2, // 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math(); "no-obj-calls": 2, // 禁止正则表达式字面量中出现多个空格 "no-regex-spaces": 2, // 禁用稀疏数组 "no-sparse-arrays": 2, // 禁止出现令人困惑的多行表达式 "no-unexpected-multiline": 2, // 禁止在return、throw、continue 和 break语句之后出现不可达代码 /* function foo() &#123; return true; console.log("done"); &#125;//错误 */ "no-unreachable": 2, // 要求使用 isNaN() 检查 NaN "use-isnan": 2, // 强制 typeof 表达式与有效的字符串进行比较 // typeof foo === "undefimed" 错误 "valid-typeof": 2, // 限制圈复杂度，也就是类似if else能连续接多少个 "complexity": [ 2, 9 ], // 强制所有控制语句使用一致的括号风格 "curly": [ 2, "all" ], // 要求 for-in 循环中有一个 if 语句 "guard-for-in": 2, // 禁用 arguments.caller 或 arguments.callee "no-caller": 2, // 定义对象的set存取器属性时，强制定义get "accessor-pairs": 2, // switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告 "default-case": 2, // 强制object.key 中 . 的位置，参数: // property，'.'号应与属性在同一行 // object, '.' 号应与对象名在同一行 "dot-location": [ 2, "property" ], // 强制使用.号取属性 // 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性 // false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;"allowKeywords": false&#125;] // allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;"allowPattern": "^[a-z]+(_[a-z]+)+$"&#125;] "dot-notation": [ 2, &#123; "allowKeywords": false &#125; ], // 使用 === 替代 == allow-null允许null和undefined== "eqeqeq": [ 2, "allow-null" ], // 不允许在 case 子句中使用词法声明 "no-case-declarations": 2, // 禁止除法操作符显式的出现在正则表达式开始的位置 "no-div-regex": 2, // 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。 "no-empty-function": 2, // 禁止使用空解构模式no-empty-pattern "no-empty-pattern": 2, // 禁用 eval() "no-eval": 2, // 禁止扩展原生类型 "no-extend-native": 2, // 禁止不必要的 .bind() 调用 "no-extra-bind": 2, // 禁止 case 语句落空 "no-fallthrough": 2, // 禁止数字字面量中使用前导和末尾小数点 "no-floating-decimal": 2, // 禁止使用类似 eval() 的方法 "no-implied-eval": 2, // 禁用 __iterator__ 属性 "no-iterator": 2, // 禁用标签语句 "no-labels": 2, // 禁用不必要的嵌套块 "no-lone-blocks": 2, // 禁止使用多个空格 "no-multi-spaces": 2, // 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串 "no-multi-str": 2, // 禁止对原生对象赋值 "no-native-reassign": 2, // 禁止在非赋值或条件语句中使用 new 操作符 "no-new": 2, // 禁止对 String，Number 和 Boolean 使用 new 操作符 "no-new-wrappers": 2, // 禁用八进制字面量 "no-octal": 2, // 禁止在字符串中使用八进制转义序列 "no-octal-escape": 2, // 禁用 __proto__ 属性 "no-proto": 2, // 禁止使用 var 多次声明同一变量 "no-redeclare": 2, // 禁止自我赋值 "no-self-assign": 2, // 禁止自身比较 "no-self-compare": 2, // 禁用逗号操作符 "no-sequences": 2, // 禁止抛出非异常字面量 "no-throw-literal": 2, // 禁用一成不变的循环条件 "no-unmodified-loop-condition": 2, // 禁用未使用过的标签 "no-unused-labels": 2, // 禁止不必要的 .call() 和 .apply() "no-useless-call": 2, // 禁止不必要的字符串字面量或模板字面量的连接 "no-useless-concat": 2, // 禁用 with 语句 "no-with": 2, // 强制在parseInt()使用基数参数 "radix": 2, // 要求 IIFE 使用括号括起来 "wrap-iife": [ 2, "any" ], // 要求或禁止 “Yoda” 条件 "yoda": [ 2, "never" ], // 禁止删除变量 "no-delete-var": 2, // 不允许标签与变量同名 "no-label-var": 2, // 禁止覆盖受限制的标识符 "no-shadow-restricted-names": 2, // 禁用未声明的变量，除非它们在 /*global */ 注释中被提到 "no-undef": 2, // 禁止将变量初始化为 undefined "no-undef-init": 2, // 禁止出现未使用过的变量 "no-unused-vars": [ 2, &#123; "vars": "all", "args": "none" &#125; ], // 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格 "array-bracket-spacing": [ 2, "never" ], //强制使用一致的缩进 第二个参数为 "tab" 时，会使用tab， // if while function 后面的&#123;必须与if在同一行，java风格。 "brace-style": [ 2, "1tbs", &#123; "allowSingleLine": true &#125; ], // 双峰驼命名格式 "camelcase": 2, // 控制逗号前后的空格 "comma-spacing": [ 2, &#123; "before": false, "after": true &#125; ], // 控制逗号在行尾出现还是在行首出现 (默认行尾) // http://eslint.org/docs/rules/comma-style "comma-style": [ 2, "last" ], //"SwitchCase" (默认：0) 强制 switch 语句中的 case 子句的缩进水平 // 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always "computed-property-spacing": [ 2, "never" ], // 文件末尾强制换行 "eol-last": 2, "indent": [ 2, 4, &#123; "SwitchCase": 1 &#125; ], // 强制在对象字面量的属性中键和值之间使用一致的间距 "key-spacing": [ 2, &#123; "beforeColon": false, "afterColon": true &#125; ], // 强制回调函数最大嵌套深度 5层 "max-nested-callbacks": [ 1, 5 ], // 强制在关键字前后使用一致的空格 (前后腰需要) "keyword-spacing": 2, // 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。） "new-cap": [ 2, &#123; "newIsCap": true, "capIsNew": false &#125; ], // 要求调用无参构造函数时有圆括号 "new-parens": 2, // 禁止使用 Array 构造函数 "no-array-constructor": 2, // 不允许空格和 tab 混合缩进 "no-mixed-spaces-and-tabs": 2, // 不允许多个空行 "no-multiple-empty-lines": [ 2, &#123; "max": 2 &#125; ], // 禁止使用 Object 的构造函数 "no-new-object": 2, // 禁止 function 标识符和括号之间出现空格 "no-spaced-func": 2, // 禁用行尾空格 "no-trailing-spaces": 2, // 禁止可以在有更简单的可替代的表达式时使用三元操作符 "no-unneeded-ternary": 2, // 强制函数中的变量要么一起声明要么分开声明 "one-var": [ 2, &#123; "initialized": "never" &#125; ], // 强制操作符使用一致的换行符 "operator-linebreak": [ 2, "after", &#123; "overrides": &#123; "?": "before", ":": "before" &#125; &#125; ], // 强制使用一致的反勾号、双引号或单引号 "quotes": [ 2, "single", "avoid-escape" ], // 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，） "semi": [ 2, "always" ], // 强制在块之前使用一致的空格 "space-before-blocks": [ 2, "always" ], // 强制在 function的左括号之前使用一致的空格 "space-before-function-paren": [ 2, "always" ], // 强制在圆括号内使用一致的空格 "space-in-parens": [ 2, "never" ], // 要求操作符周围有空格 "space-infix-ops": 2, // 强制在一元操作符前后使用一致的空格 "space-unary-ops": [ 2, &#123; "words": true, "nonwords": false &#125; ], // 强制在注释中 // 或 /* 使用一致的空格 "spaced-comment": [ 2, "always", &#123; "markers": [ "global", "globals", "eslint", "eslint-disable", "*package", "!" ] &#125; ] &#125;&#125;; 参考1：老雷篇(Node.js实战) 参考2：细节篇 ESLinit中文版文档 ESLinit中文版文档 - 规则配置]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[永远不要对人怀有恨意或怨言]]></title>
      <url>%2F2017%2F02%2F09%2F%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%AF%B9%E4%BA%BA%E6%80%80%E6%9C%89%E6%81%A8%E6%84%8F%E6%88%96%E6%80%A8%E8%A8%80.html</url>
      <content type="text"><![CDATA[仇恨和怨意，会降低大脑灵活性，导致智力严重缩水，偏离自我的发展轨道。 善未必聪明，但坏必蠢 不要然自己成为蠢人，因此千万不可怨恨 ( 虐你千百遍，依旧带其如初恋 )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式-策略模式(2)]]></title>
      <url>%2F2017%2F02%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F(2).html</url>
      <content type="text"><![CDATA[策略模式( Strategy )：将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定独立性，不会随客户端变化而变化 策略模式( Strategy )：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换 使用策略模式计算奖金 年终奖是根据员工的工资基数和年底绩效来发放的 绩效S的人有4倍工资、绩效A的人有3倍工资，绩效B的人有2倍工资 最初的代码实现(1)1234567891011121314// calculate:计算，bonus:奖金，salary:薪水，performance:工作情况var calculateBonus = function(performanceLevel, salary) &#123; if (performanceLevel === 'S') &#123; return salary * 4; &#125; if (performanceLevel === 'A') &#123; return salary * 3 &#125; if (performanceLevel === 'B') &#123; return salary * 2 &#125;&#125;calculateBonus('S',25000);calculateBonus('B',9000); 非常简单的代码，但是存在的问题也显而易见。 calculateBonus 函数比较庞大，包含了很多if-else语句，这些语 句需要覆盖所有的逻辑分支 calculateBonus 函数缺乏弹性，如果增加了一种新的绩效等级C，或者想把绩效S的奖金修改为5，那我们必须深入 calculateBonus 函数的内部实现，这违反 开放-封闭 原则 算法的复用性差，如果在程序的其他地方需要重用这些计算奖金的算法呢？我们的选择只有复制和粘贴 使用组合函数重构代码(2)123456789101112131415161718192021var performanceS = function(salary) &#123; return salary * 4;&#125;var performanceA = function(salary) &#123; return salary * 3;&#125;var performanceB = function(salary) &#123; return salary * 2;&#125;var calculateBonus = function(performanceLevel, salary) &#123; if (performanceLevel === 'S') &#123; return performanceS(salary); &#125; if (performanceLevel === 'A') &#123; return performanceS(salary); &#125; if (performanceLevel === 'B') &#123; return performanceS(salary); &#125;&#125;calculateBonus('A', 18000); 组容易想到重构代码的办法就是：使用组合函数来重构代码 把各种算法封装到一个个的小函数里，这些小函数有这良好的命名规范、一目了然地知道它对应着那种算法，他们可以被复用在程序的其他地方 程序确实得到了一些非常有限的改善，但是依然没有解决最重要的问题 calculateBonus 函数有可能越来越大 协同变化的时候缺乏弹性 将不变的部分 和 变化的部分 隔开是每个设计模式的主题 策略模式的目的就是将算法的使用与算法的实现分离开来 一个基于策略模式的程序至少由两部分组成。 一组策略类，策略类封装了具体的算法，并负责具体的计算过程 环境类Context，Context接受客户的请求，随后把请求委托給摸一个策略类。要做到这点，说明Context中药维持对某个策略对象的引用 策略模式重构代码(3-1)123456789101112131415161718// JavaScript版本的策略模式// 策略模式指的是定义一系列的算法，并且把他们封装起来。var strategies = &#123; "S": function(salary) &#123; return salary * 4; &#125;, "A": function(salary) &#123; return salary * 3; &#125;, "B": function(salary) &#123; return salary * 2; &#125;&#125;var calculateBonus = function(level, salary) &#123; return strategies[level](salary);&#125;console.log(calculateBonus('S', 30000));console.log(calculateBonus('A', 20000)); 通过使用策略模式重构代码，消除了原程序中大片的条件分支语句。 所有跟计算奖金有关的逻辑不再放在Context中，而是分布在各个策略对象中。Context并没有计算过奖金的能力，而是把这个职责委托給了某个策略对象。每个策略对象负责的算法已被各自封装在对象内部。 当我们对这些策略对象发出”计算奖金”的请求时，它们会放回各自不同的计算结果，这正是对象多态性的体现，也是”它们可以相互替换”的目的，替换Context中当前保存的策略对象，便能执行不同的算法来得到我们想要的结果 策略模式 - 表单校验 将用户输入的数据交給后台之前，常常要做一些前端力所能及的校验工作，比如注册的时候需要校验是否填写用户名，密码的长度是否符合规定。。 这样是为了避免因为提交不合法数据而带来的不必要的网络开销。 在点击提交按钮之前，有几条校验的逻辑 姓名、手机号、验证码不能为空 手机号、验证码 非错误 手机号必须符合格式 输入框需过滤特殊字符 - 防SQL注入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# validator:校验# strategy:策略// 第一步：把校验逻辑都封装成 '策略对象'var strategies = &#123; isNonEmpty: function(value, errorMsg) &#123; if (value === '') &#123; return errorMsg; &#125; &#125;, minLength: function(value, length, errorMsg) &#123; if (value.length &lt; length) &#123; return errorMsg; &#125; &#125;, isMobile: function(value, errorMsg) &#123; if (!/^1[3|5|8][0-9]&#123;9&#125;9$/.test(value)) &#123; return errorMsg; &#125; &#125;&#125;;// 第二步：实现Validator类var Validator = function()&#123; this.cache = [];// 保存校验规则&#125;;// 通过validator.add()方法向validator对象中添加一些校验规则Validator.prototype.add = function( Dom, Rule, ErrorMsg)&#123; var ary = Rule.split(':');// 把strategy和参数值分开minLength:9 this.cache.push(function()&#123;// 把校验的步骤用空函数包装起来，并且放入this.cache中、在开始校验的时候进行循环调用 // 用户挑选的 strategy var strategy = ary.shift(); // 把input中的value值添加进参数列表 // 调用:strategies.minLength(value, length, errorMsg); ary.unshift(Dom.value); // 把errorMsg添加进参数列表 ary.push(errorMsg); // 调用封装的策略对象 // Dom替换Function类里this对象 // ary将作为参数(arguments)传递给Function return strategies[strategy].apply(Dom, ary); &#125;);&#125;// 通过validator.start()启动校验Validator.prototype.start = function()&#123; // validatorFunc 一个独立变量、循环之后执行 // 当前for循环的 结束界点是 this.cache取值为undefind的时候 for(var i=0; validatorFunc; validatorFunc=this.cache[i++])&#123; var msg = validatorFunc(); if(msg)&#123; return msg &#125; &#125;&#125;;// 第三步：执行步骤 - 用户向Validator类发送请求var validataFunc = function()&#123; var validator = new Validator();// 创建validator对象 // 向this.cache中添加校验规则 validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空~'); validator.add(registerForm.password, 'minLength:6', '密码长度不能少于6位~'); validator.add(registerForm.phoneNumber, 'isMobile', '手机号格式不正确~'); // 获得校验结果 var errorMsg = validator.start(); return errorMsg;// 返回校验结果：strategies中的错误返回值&#125;// 第四步：提交表单var registerForm = document.getElementById('registerForm');registerForm.onsubmit = function()&#123; // 如果errorMsg有确切的返回值，说明未通过校验 var errorMsg = validataFunc(); if(errorMsg)&#123; alert(errorMsg); return false;// 阻止表单提交 &#125;&#125; 当前的校验方法中用到了 原型链模式 策略模式 在 validator.add()方法内: apply(Dom, ary); 改变当前value的Dom的this值，改变this的同时传递this.cache数组内的参数(arguments) 并且执行 在 validator.add()方法内:在 this.cache.push() 中使用闭包 在 validator.start()方法内：for循环的结束节点用的是数组的空值 undefined 进行判定的，初始条件是一个不为false的函数值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式 - 单例模式(1)]]></title>
      <url>%2F2017%2F02%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F(1).html</url>
      <content type="text"><![CDATA[单例模式( Singleton )：确保只有一个实例，并提供全局访问 在 JavaScript 开发中，我们经常会把全局变量当做单例来使用 var a = {}; 命名空间( namespace )的管理 命名空间：为了让代码更易懂，人们常常用单词或者拼音定义变量或者方法，但由于人们可用的单词或者汉字拼音是有限的，所有不同的人定义的变量使用的单词名称很有可能重复，此时就需要使用命名空间来约束每个人定义的变量来解决这类问题。 1234567891011var BusinessGoInit = &#123; getServerTime: function() &#123; // 获取服务器时间戳 &#125;, isUserVip: function() &#123; // 是否为会员 &#125;, toShortUrl: function() &#123; // 短链接 &#125;&#125; 模块分明 通过单例模式来管理代码库的各个模块 123456789101112131415161718var A = &#123; Util: &#123; util_method1: function() &#123;&#125;, util_method2: function() &#123;&#125; &#125;, Tool: &#123; tool_method1: function() &#123;&#125;, tool_method2: function() &#123;&#125; &#125;, Ajax: &#123; get: function() &#123;&#125;, post: function() &#123;&#125; &#125;, others: &#123; xxx: function() &#123;&#125;, yyy: function() &#123;&#125; &#125;&#125; 管理静态变量123456789101112131415161718var Conf = (function() &#123; // 私有变量 var config = &#123; MAX_NUM: 100, MIN_NUM: 1, COUNT: 1000 &#125; // 返回取值器对象 return &#123; // 通过取值器方法访问静态变量 get: function(name) &#123; return config[name] ? config[name] : null; &#125; &#125;&#125;)();var count = Conf.get('COUNT');console.log(count); // 1000// 静态变量只能访问，不能修改。并且无创建后就能使用 惰性单例 惰性单例：在需要的时候才创建对象实例。惰性单例是单例模式的重点，这种技术在实际开发中非常有用。 案例：登陆窗、在一个项目里登陆窗总是唯一的，不可能同时存在两个登陆窗口的情况 ( 两种解决方案 ) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 解决方案一：// 1、在页面加载完成的时候便创建好这个div弹窗// 2、弹窗一开始肯定是隐藏的姿态// 3、用户点击登陆按钮，显示弹窗var loginLayer = (function()&#123; var oDiv = document.createElement('div'); oDiv.innerHTML = '我是登录框'; oDiv.style.display = 'none'; document.body.appendChild(oDiv); return oDiv;&#125;)();document.onclick = function()&#123; loginLayer.style.display = 'block';&#125;// 这种方式有一个问题，也许我们进入当前项目根本不需要登陆操作// 应为登陆窗口总是在一开始就被创建好，那么就会白白浪费掉一些DOM节点// 解决方案一：改进1var createLoginLayer = function()&#123; var oDiv = document.createElement('div'); oDiv.innerHTML = '我是登录框'; oDiv.style.display = 'none'; document.body.appendChild(oDiv); return oDiv;&#125;document.onclick = function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;// 改进方案虽然实现了惰性的目的，但是失去了单例的效果。// 当我们每次点击登陆按钮的时候，都会创建一个新的登录弹窗div// 虽然我们可以在点击弹出上的关闭按钮时，把这个弹出从页面中删除// 但这样频繁地创建和删除节点明显是不合理的，也是不必要的// 解决方案一：改进2// 可以使用一个变量来判断是否已经创建过登录弹出了var createLoginLayer = (function()&#123; var div = null; return function()&#123; if(!div)&#123; div = document.createElement('div'); div.innerHTML = '我是登录弹出'; div.style.display = 'none'; document.body.appendChild(div); &#125; return div; &#125;&#125;)();document.onclick = function()&#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;// 这样写就完成了一个可用的惰性单例，但还有一些问题// 创建对象和管理单例都放在createLoginLayer对象内部// 复用性 - 若下次创建iframe或者script，就必须如法炮制// 把createLoginLayer函数几乎照抄一遍 12345678910111213141516171819202122232425262728293031323334// 解决方案二：按需加载// 我们把如何管理单例的逻辑从原来的代码中抽离出来// 封装在getSingle函数内部，创建对象的方法fn被当做参数动态的传入var getSingle = function(fn)&#123; var result; return function()&#123; // return result || (result = fn()); return result || (result = fn.apply(this,arguments)); &#125;&#125;var createLoginLayer = function()&#123; var oDiv = document.createElement('div'); oDiv.innerHTML = '我是登录框'; oDiv.style.display = 'none'; document.body.appendChild(oDiv); return oDiv;&#125;var createSingleLoginLayer = getSingle(createLoginLayer);document.onclick = function()&#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';&#125;// 我们把创建实例对象的职责 和 管理单例的职责分别放置在两个方法里面// 两个方法可以独立变化而互不影响，当他们链接在一起，就完成了创建唯一实例对象的功能// 再试试创建唯一的iframe用于动态加载第三方页面var createSingleIframe = getSingle(function()&#123; var iframe = document.createElement('iframe'); document.body.appendChild(iframe); return iframe;&#125;);document.onclick = function()&#123; var loginLayer = createSingleIframe(); loginLayer.src = 'http://hao123.com'&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[this深入理解]]></title>
      <url>%2F2016%2F12%2F31%2Fthis%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3.html</url>
      <content type="text"><![CDATA[回想起这6个月的工作经历、业务做了不少，熟练度直线上升。然而归纳却寥寥无几，这让我再次抓起了我当初简历博客的初衷，不花时间精力去总结，平时业务上用到的零散的知识就很难形成体系。善于归纳总结：如果不善于归纳总结，每次做完项目就结束了，进入循环，那么永远是士兵，不要总是讲一些口号，喊口号的人可以当主持人，但是不能当将军。不归纳就不能前进，不前进就永远在原地踏步。认识一步步前进的，只要一小步一小步地前进，过几年当你汇总总结时，就会发现你前进了一大步。 This、call、apply This：JavaScript的this总是指向一个对象。 而具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。 this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用 在理解 this 是什么❓首先必须要找到”调用位置“，然后判断符合那种规则。 当一个函数被调用时，会创建一个”执行上下文环境”： 包含函数在哪里被调用 ( 调用栈 ) 。 函数调用方法。 传入的参数等信息。 this 就是记录的其中一个属性，会在函数执行的过程中用到。 This指向大致可以分为如下四类： 作为对象的方法调用。 作为普通函数调用。 构造器调用 Function.prototype.call 和 Function.prototype.apply 调用 1、作为对象的方法调用 当函数作为对象的方法被调用时, this 指向该对象 12345678// 当函数作为对象的方法被调用时、this指向该对象var obj = &#123; a:1, getA: function()&#123; alert(this === obj);//true alert(this.a);//1 &#125;&#125; 1-1、隐式绑定 另一条需要考虑的规则是： 调用位置是 否有上下文 — “对象” ，或者说 是否被某个对象拥有( 包含 ) 123456789101112function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;obj.foo();## 1：无论是直接在obj中定义、还是先定义再添加为引用属性，这个函数严格来说都不属于obj对象。## 2：然而，调用位置会使用obj上下文来引用函数，因此你可以说函数被调用时obj对象"拥有"或者"包含"了它。## 3：无论我们如何称呼这个模式，当foo()被调用时，它的落脚点确实指向obj对象。当函数引用有上下文对象时，"隐式绑定"规则会把函数调用中的"this"绑定到这个上下文对象。因为调用foo()时this被绑定到obj，所以this.a和obj.a是一样的## 4：对象属性引用链中，只有最后一层( 最顶层 )会影响到调用位置 1-2、隐式绑定丢失 最常见的隐式绑定问题： 被”隐式绑定”的函数会丢失绑定对象，也就是说它会应用”默认绑定”，从而把this绑定到全局对象或者”undefined”上，取决于是否是”严格模式” 解决办法：使用”显示绑定”的方案 call(...)和apply(…) 的”硬绑定”模式 123456789101112131415161718192021222324252627282930// 丢失案例一：堆内存地址的引用function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2, foo:foo&#125;var bar = obj.foo;var a = "oops,global";bar();// oops,global## 虽然bar是obj.foo的一个引用。## 但是实际上，它引用的是foo函数本身,是foo函数在堆内存空间的地址(复制的是指针的指向)## 本质上：bar() == foo();## 因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定。// 丢失案例二：非常常见并且非常出乎意料的情况(参数传递)function foo()&#123; console.log(this.a);&#125;function doFoo(fn)&#123; fn();&#125;var obj = &#123; a:2, foo:foo&#125;var a = "oops,global";doFoo(obj.foo);## 参数传递其实"就是"一种隐式赋值，因此我们传入函数时也会被隐式赋值。 引用类型参数传递问题 引用类型：引用类型传递的是指针的方向 12345678function setName(obj)&#123; obj.name = 'aaa'; return obj;&#125;var person = new Object();person.name = 'bbb';var newPerson = setName(person);console.log(person.name + ' || ' + newPerson.name); http://www.cnblogs.com/zareb/p/5699571.html 12345678910111213function setName(obj) &#123; obj.name = 'aaa'; var obj = new Object(); // 如果是按引用传递的,此处传参进来obj应该被重新引用新的内存单元 obj.name = 'ccc'; return obj;&#125;var person = new Object(); person.name = 'bbb';var newPerson = setName(person);console.log(person.name);console.log(newPerson.name); 2、作为普通函数调用 ( this - 默认绑定 ) 当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的 JavaScript 里，这个全局对象是 window 对象。 123456789101112131415161718192021222324252627282930// 使用普通函数时、其内的this总是指向window// 在代码中，getName()是直接使用不带任何修饰的函数引用进行调用的。因此只能使用"默认绑定"，无法应用其他规则。// 如果是严格模式( strict mode ),那么全局对象将无法使用默认规则，因此this会绑定到"undefined"上// 案例一：window.name = 'globalName';var getName = function()&#123; return this.name;&#125;console.log(getName());//globalName// 案例二：引用getName在堆内存中的地址window.name = 'globalName';var myObject = &#123; name:'ntscshen', getName:function()&#123; return this.name; &#125;&#125;var myName = myObject.getName;console.log(myName());// 案例三：在事件函数内部、有一个局部的方法。此方法被调用时，方法内部的this指向了windowdocument.getElementById('div1').onclick = function()&#123; console.log(this.id);// 'div1' //var _this = this;// 简单的解决方案 var callBack = function()&#123; //console.log(_this.id);// 'div1' console.log(this.id);// 'window' &#125; callBack();&#125;## 没当你想要把this和"词法"作用域的查找混合使用时，一定要提醒自己，这是无法实现的。 3、构造器调用4、 Function.prototype.call 和 Function.prototype.apply4-1：硬绑定 硬绑定的典型应用场景就是：创建一个包裹函数，传入所有的参数并返回接收到的所有值。 1234567891011121314151617181920212223242526// 案例一：function foo()&#123; console.log(this.a);&#125;var obj = &#123;a:2&#125;var bar = function()&#123; foo.call(obj);&#125;;bar();setTimeout(bar,100);bar.call(window);// 我们首先创建了函数bar()，并在它的内部手动调用了foo.call(obj),因此强制把foo的this绑定到了obj。无论之后如何调用函数bar，它总会手动在obj上调用foo。这种绑定是一种显示的强制绑定，因此称之为"硬绑定"// 案例二：function foo()&#123; console.log(this.a,something); return this.a + something;&#125;function bind(fn, obj)&#123; return function()&#123; return fn.apply(obj, arguments); &#125;;&#125;var obj = &#123;a:2&#125;;var b = bar(3);console.log(b);// 由于硬绑定是一种非常常用的模式，所以在ES5中提供了内置的方法Function.prototype.bind,它的用法如下]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手机号码中间部分替换成星号]]></title>
      <url>%2F2016%2F12%2F07%2F%E6%89%8B%E6%9C%BA%E5%8F%B7%E7%A0%81%E4%B8%AD%E9%97%B4%E9%83%A8%E5%88%86%E6%9B%BF%E6%8D%A2%E6%88%90%E6%98%9F%E5%8F%B7.html</url>
      <content type="text"><![CDATA[手机号中间4未数字使用星号替换 字符串截取 正则 字符串截取12345678910// 字符串截取 + 拼接'18500009973'.substr(0, 3) + '****' + '18500009973'.substr(7, 11);// 优化:确保输入的是字符串类型function formatPhone(phone) &#123; if (typeof phone == 'number')&#123; phone = phone.toString(); &#125; return phone.substr(0, 3) + '****' + phone.substr(7, 11);&#125;// 什么❓您不知道toString()是干什么的❓请看最底部 正则12345678function formatPhone(phone) &#123; if (typeof phone == 'number')&#123; phone = phone.toString(); &#125; return phone.replace(/(\d&#123;3&#125;)\d&#123;4&#125;(\d&#123;4&#125;)/, '$1****$2');&#125;// 匹配前面三个数字，讲匹配的值給$1,然后匹配中间4个数字，再匹配最后4个数字給$2// 什么❓您不会正则❓好吧！我也只会一点点 JavaScript toString()函数详解toString() 函数用于将当前对象以字符串的形式放回。 由于该方法属于 Object 对象，因此所有的对象都”继承“了 Object 的对象实例，所有的的实例对象都可以使用该方法、所有主流浏览器均支持该函数 JavaScript的许多内置对象都重写了该函数、以实现更适合自身的功能需求 类型 描述 Number 返回数值的字符串表示。(可以指定转换的 进制 ) Number.toString详细说明地址 Boolean 如果布尔值是true，则返回”true”,否则放回”false” Array 将Array的每个元素转换为字符串，并将它们以此连接起来，两个元素之间用英文逗号作为分隔符进行拼接 Date 返回日期的文本表示 Error 返回一个包含相关错误信息的字符串。 Object(默认) 返回”[object ObjectName]”，其中 ObjectName 是对象类型的名称。 Function 返回如下格式的字符串，其中 functionname 是一个函数的名称，此函数的 toString 方法被调用： “function functionname() { [native code] }” 实例:console 12345678910111213141516171819// 数组var array = ["ntscshen",true,"哈哈",99];array["ntscshen", true, "哈哈", 99]array.toString()"ntscshen,true,哈哈,99"// 布尔var bool = true;booltruebool.toString()"true"// 日期var date = new Date;dateWed Dec 07 2016 14:44:42 GMT+0800 (CST)date.toString()"Wed Dec 07 2016 14:44:42 GMT+0800 (CST)"// 数字var num = 12;document.writeIn(num.toString());// 什么❓您不知道writeIn❓那您知道write吗❓知道它们之间的区别吗❓知道如何在console打印内容吗❓知道打印的几种方式吗❓ write和writeIn document.write(&#39;hello word&#39;) 方法可向文档写入 HTML 表达式或 JavaScript 代码。 主要用于简单的打印内容到页面上 writeIn() 区别于 write() 的地方就是、 writeIn() 在末尾加了一个空格 console console.log() 向web控制台输出一条消息 (输出普通信息) console.dir() 向web控制台打印出该对象的所有属性和属性值，这个方法是我经常使用的 不知道比for in方便了多少 console.debug() console.log方法的别称，使用方法可以参考Console.log() console.warn() 输出警告信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webPlayer使用方法总结]]></title>
      <url>%2F2016%2F12%2F02%2FwebPlayer%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[[TOC] webPlayer 使用方法的一些总结 ( 建议先仔细阅读WebPlayerSDK点播.pdf和 WebPlayerSDK直播.pdf ) 点播播放器相关 文档中给出的 playId() 方法在页面只有一个点播播放器的时候可以正常使用，但当页面中有直播播放器时再次调用点播播放器的 playId() 方法就会失效，页面不会报错代码也会执行，只是执行完毕后没有出现预期的效果。初步猜测是因为其他播放器对这个功能造成了影响。解决方法是，重新创建一个播放器覆盖原有播放器。 当点播播放器中的视频是仅会员可看时，未登录用户点击此视频时播放器内部会提示用户登陆，此时要想实现登陆操作需要在点播播放器的页面接口集合 ( interface对象 ) 中传入 123openLoginDialog :function()&#123; verifyUserloginStatus();&#125; 当点播播放器中的视频是仅会员可看时，已登陆的非会员用户点击此视频时，播放器内部会提示用户开通会员，pc页面点击此按钮可以正常跳转到支付页面；m站页面点击此按钮无效，需要用事件委托的形式给开通会员按钮绑定跳转到支付页面的事件； PC页面中当点播播放器中的视频是仅会员可看时，用户中途登陆是会员的账户时播放器不会刷新（有的仅会员可看视频可以免费看前6分钟，所以存在中途登陆的情况），会依然提示他购买会员。调用播放器的 loginStateChange() 方法并未能解决问题，解决办法是 12345678910//监听登录状态 切换时触发$(function () &#123; LEPass.onStatusChange(function (type, userInfo) &#123; if (type == "signIn" ) &#123; ($(".na-drama-list").find(".playing").find("a").data("pid")) &#123; dianboPlayer($(".na-drama-list").find(".playing").find("a").data("pid")); &#125; &#125; &#125;);&#125;); （找到当前正在播放视频的id，利用此id重新创建播放器或者将id传入到 playId() 方法中，具体怎么操作需要看当前的代码结构）；m站页面没有此问题，因为只要登陆状态发生改变m站页面会自动强制刷新。 关于点播播放器续播的问题可以调用播放器的onPlayerVideoComplete事件回调 12345onPlayerVideoComplete: function () &#123; return &#123; status: 'playerContinue' &#125;&#125; 直播播放器相关直播分为“直播中”、“未开始”、“已结束”三种状态，其中要注意已结束的直播视频（也就是“回看”视频），从后台取出来的回看视频数据一般会带有一个名为 recordingId 的参数，但是有的原本正在直播中视频在刚刚结束的时候虽然已经变成了回看视频，但是并未带有 recordingId 参数。所以，对于回看视频： 如果取到recordingId参数就将recordingId传入到点播播放器； 如果取不到recordingId参数就将原本的视频id传入直播播放器。 一些共同的问题总结 关于播放器黑边，如果视频的比例全部一样，那么只要保证播放器盒子的宽高比和视频的一致就没有黑边了；如果视频的比例不一致，请尽可能将播放器的宽高调到一个合适的比例以保证黑边在所有视频中都尽可能小。 目前已知直播播放器会影响到点播播放器的 playId() 方法，由于本次项目经验有限，关于播放器之间的相互影响以及其他经验还需要屏幕外的你在未来的项目中进行总结。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vue新手(1)]]></title>
      <url>%2F2016%2F11%2F29%2Fvue%E6%96%B0%E6%89%8B-1.html</url>
      <content type="text"><![CDATA[Vue一个mvvm框架、比较容易上手、小巧( 适合：移动项目 ) HTML代码配合Json、在new一个vue实例 既然选择使用当前的框架、请遵循其标准 vue.js引用地址 &lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt; See the Pen Vue.js小案例 by ntscshen@163.com (@ntscshen) on CodePen. Vue.js小案例1 vue构造器是由一个作用域(el: ‘#app’)和一个数据中心组成( data:[] ) Vue常用指令 指令：带有 v- 前缀的特殊属性，指令属性的值、语气是 单一JavaScript表达式 。指令的职责就是当其表达式的值改变时相应地将某些行为应用到DOM上 v-model v-for循环 v-on:click绑定事件，methods( vue中单独提供的接口添加方法 ) 案例1：点击添加按钮、循环添加一组数据(数组、对象) 案例2：点击按钮div元素消失 案例3：todolist; TODO：使用bootstrap( 只需要记忆class类名的框架 ) 案例4：v-if随机数 Math.random() 案例5：显示隐藏 条件渲染 因为 v-if 是一个指令(指令的职责就是当其表达式的值改变时相应地将某些行为应用到DOM上)，需要将它添加到一个元素上。我们可以把一个 元素当做包装元素，并在上面使用 v-if ,最终的渲染结果不会包含它 v-else 元素必须紧跟在 v-if 或 v-show 元素的后面 — 否则它不能被识别 v-show 的元素会始终渲染并保持在DOM中、简单的切换元素的CSS属性 display 。并且其不支持 语法 v-if VS v-show v-if 是真实的条件渲染，应为它会确保条件块在切换当中适当地销毁与重建条件内的事件监听器和子组件 v-if 它是 惰性的 ：如果在初始渲染时条件为假，则什么也不做 — 在条件第一次变为真时才开始局部编译( 编译会被缓存起来 ) 相比之下， v-show 简单的多 — 元素始终被编译并保留，只是简单地基于CSS切换 一般来说， v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换使用 v-show 较好，如果在运行时条件不大可能改变则使用 v-if 较好。 列表渲染 v-for 指令根据一组数组的选项列表进行渲染。以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名 在 v-for 快中，我们拥有对父作用域属性的完全访问权限。 v-for 还支持一个可选的第二个参数为当前项的索引 也可以使用 of 替代 in 作为分隔符，因为它是最接近JavaScript迭代器的语法 基本用法 ( 数组迭代 ) 1234567891011121314151617// item 项目&lt;ul id=&quot;Demo1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var vm = new Vue(&#123; el: &apos;#Demo1&apos;, data: &#123; items: [ &#123;message: &apos;Foo&apos;&#125;, &#123;message: &apos;Bar&apos;&#125;, &#123;message: &apos;Shen&apos;&#125; ] &#125;&#125;);&lt;/script&gt; 用法二 1234567891011121314151617181920// 在v-for 快中，我们拥有对父作用域属性的完全访问权限。v-for还支持一个可选的第二个参数作为当前项目的索引// 您也可以使用of 代替 in 作为分隔符，因为它是最接近JavaScript迭代器的语法&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;ul id=&quot;Example&quot;&gt; &lt;li v-for=&quot;(item, index) in items&quot;&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var vm = new Vue(&#123; el: &apos;#Example&apos;, data: &#123; parentMessage: &apos;Parent&apos;, items: [ &#123;message: &apos;Foo&apos;&#125;, &#123;message: &apos;Bar&apos;&#125; ] &#125;&#125;);&lt;/script&gt; 用法三 1234567// 如果同v-if模板，你可以用带有v-for 的 &lt;template&gt;标签来渲染多个元素快 &lt;ul&gt; &lt;template v-for=&quot;item in items&quot;&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li style=&quot;height: 5px; background-color: #efe0ce;&quot;&gt;&lt;/li&gt; &lt;/template&gt; &lt;/ul&gt; 基础用法 - 对象迭代 1234567891011121314151617181920212223// 可以使用 v-for 通过一个对象的属性来迭代// (value, key, index) in object// 顺序严格规定(value(1:值), key(2:键), index(3:索引))// value 值// key 键// index 索引&lt;ul id=&quot;object&quot;&gt; &lt;li v-for=&quot;value in object&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var vm = new Vue([ el: &quot;#object&quot;, data: &#123; object: &#123; name: &apos;ntscshen&apos;, gender: &apos;男&apos;, age: 24, &#125; &#125;]);&lt;/script&gt; 数组和对象迭代总结：( 顺序严格规定 ) 1、数组：v-for=”(item, index) in items” 内容，索引 2、对象：v-for=”(value, key, index) in object” 值，键，索引 3、整数：v-for=”n in 10” 4、组件：在自定义组件中，你可以想任何普通元素一样使用 v-for 缩写： Vue为两个最为常用的指令提供了特别的缩写 v-bind:href 缩写 :href v-on:click 缩写 @click ​ vue监听 监听数据值的变化( 当改变时、修改内容 ) 1234567891011121314151617&lt;script&gt;var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; num1: 0, num2: 10, total: 0 &#125;, watch: &#123; &quot;num1&quot;:function(newval,oldval)&#123; if(this.num1 &gt;= 3)&#123; this.total = this.total - this.num2; &#125; &#125; &#125;&#125;);&lt;/script&gt; Class与Style绑定 数据绑定一个常见需求是 - 操作元素的class列表和它的内联样式。因为它们都是属性，我们可以用v-bind处理。 :class :class=&quot;{red: isRed}&quot; :class=&quot;{classA,classB}&quot; data数据中映射类名 :class=&quot;{&#39;class-A&#39;:isA,&#39;class-B:isB&#39;}&quot; 在字面量方式里 - 第一方法的衍生 :class=[classA,{&#39;class-C&#39;:isC,&#39;class-B&#39;:isB}] 组合方式 :style :style=&quot;{fontSize: size + &#39;px&#39;}&quot; :style=&quot;{styleObjectA,styleObjectB}&quot; data数据映射 12345678910data: &#123; styleObjectA:&#123; color: &apos;red&apos;, fontSize: &apos;100px&apos; &#125;, styleObjectB:&#123; background-color: &apos;pink; border: &apos;2px solid red&apos;; &#125;&#125; 为元素绑定动态的属性、要使用v-bind这个质量、质量就是一些特别的属性、一般以 v- 开头 在元素上面动态的去应用一些CSS类、使用 v-bind 指令绑定 class 属性 对象 数组 [buttonClass, colorClass] 映射对应的Class类名、在 data 数据中添加 key 和 映射的类名 12345678var dataSource = &#123; buttonClass: &apos;ui button&apos;,// ui button 类名 colorClass: &apos;violet&apos;// violet 类名&#125;var vm = new Vue(&#123; el: &apos;#app&apos;, data: dataSource&#125;); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;ui container&quot;&gt; &lt;div class=&quot;ui hidden divider&quot;&gt; &lt;button v-bind:class=&quot;[buttonClass, colorClass, classObject]&quot;&gt;按钮&lt;/button&gt; &lt;h2 style=&quot;color: red;&quot;&gt;绑定类&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;我们可以动态的去设置一下这个按钮的颜色 &lt;strog&gt;vm.colorClass=&quot;green&quot;&lt;/strog&gt;&lt;/li&gt; &lt;li&gt;有一些css类你可能希望，根据某一个值去动态的添加&lt;/li&gt; &lt;li&gt;在绑定类的数组里给其添加变量&lt;strong&gt;&#123;loading: isLoading&#125;&lt;/strong&gt;&lt;/li&gt; &lt;li style=&quot;color: violet&quot;&gt;这块的意思就是：&lt;p style=&quot;red&quot;&gt;如果应用里面的isLoading值是true的话、就会在这个元素的上面去添加一个loading这样的一个css类&lt;/p&gt;&lt;/li&gt; &lt;li&gt;在Data数据中添加&lt;p&gt;isLoading:false&lt;/p&gt;。之后在控制台动态的设置isLoading的值&lt;/li&gt; &lt;li&gt;我们可以动态的去设置一下这个按钮的颜色 &lt;stro&gt;vm.colorClass=&quot;green&quot;&lt;/stro&gt;&lt;/li&gt;\ &lt;li&gt;表达式可以在v-bind:class=&quot;[isActive ? activeClass :&apos;&apos;, errorClass]&quot; 绑定类中去写&lt;/li&gt; &lt;!-- &lt;div v-bind:class=&quot;[&#123;active:isActive&#125;,errorClass]&quot;&gt;&lt;/div&gt; --&gt; &lt;!-- v-bind 有点类似于jQuery的css。只是在这之上映射了一层。data 如果直接这样。模板会跟加清晰 data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;14px&apos;; &#125; &#125; &lt;div :style=&quot;styleObject&quot;&gt;&lt;/div&gt; --&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; buttonClass: &apos;ui button&apos;, colorClass: &apos;violet&apos;, isLoading: true, error: null &#125;, computed:&#123; classObject: function()&#123; return &#123; loading: this.isLoading &amp;&amp; !this.error, &#125; &#125; &#125; &#125;);&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[需求文档]]></title>
      <url>%2F2016%2F11%2F28%2F%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3.html</url>
      <content type="text"><![CDATA[需求文档 无论是正式的产品需求或是Demo需求( 必须要出产品需求 ) 基于对当前产品需求的了解之后 - 才能运用对应的技术站进行开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac上网络抓包Charles]]></title>
      <url>%2F2016%2F11%2F19%2FMac%E4%B8%8A%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85Charles.html</url>
      <content type="text"><![CDATA[抓包？就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全。抓包也经常被用来进行数据截取等。 为什么调试配置Host？ 我们知道在网络上访问网站，要首先通过DNS服务器把网络域名（www.XXXX.com）解析成61.XXX.XXX.XXX的IP地址后，我们的计算机才能访问。要是对于每个域名请求我们都要等待域名服务器解析后返回IP信息，这样访问网络的效率就会降低，而Hosts文件就能提高解析效率。 在很多单位的局域网中，会有服务器提供给用户使用。但由于局域网中一般很少架设DNS服务器，访问这些服务要输入难记的IP地址，对不少人来说相当麻烦。现在可以分别给这些服务器取个容易记住的名字，然后在Hosts中建立IP映射，这样以后访问的时候我们输入这个服务器的名字就行了。 对于Lotus的服务器和一些数据库服务器，在访问时如果直接输入IP地址那是不能访问的，只能输入服务器名才能访问。那么我们配置好Hosts文件，这样输入服务器名就能顺利连接了。 Charles Mac下常用的网络封包截取工具(免费30天 - 试用期过后建议购买正版) Charles通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析 Charles主要功能 截取Http和Https网络封包。 支持重发网络请求，方便前后端调试。 支持修改网络请求参数。 支持网络请求的截获并动态修改。 支持模拟满网速网络 安装步骤下载好Charles - 打开下载包( .dmg后缀的文件 )后将Charles拖到Application目录下即可。 启动Charles后、第一次Charles会请求您给它设置系统代理的权限。图例如下！ 源： 译： Firefox代理服务器配置 源： 译： 在Firefox中打开 https://addons.mozilla.org/zh-CN/firefox/addon/charles-proxy/ 源： 译： 这样在Firefox可以抓包Proxy -&gt; Mozilla Firefox Proxy 将Charles设置成系统代理Charles主界面 Structure：结构( 视图将网络请求按访问的域名分类 ) Sequence：先后次序( 视图将网络请求按访问的时间排序 ) 根据具体的需求在这两个视图之间来回切换、大多数情况下截获的请求会很多，Charles提供了一个简单Filter功能，可以输入关键字来快速筛选URL中带指定关键字的网络请求 对于具体的网络请求 若请求的内容是POST表单、Charles会自动将表单进行分项显示 若是JSON格式的内容、Charles会自动将JSON内容格式化 若是图片、Charles会显示出图片的预览 抓包工具之断点修改( 重点 ) 更改返回数据来测试临界情况：这种做法可以让一个前端开发人员独立完成测试而不用拉一个后端一起联调，并且各种特殊维度，临界点都可以独立完成。仅仅自己在青花瓷上改来改去就可以达到效果了。 在实际的工作中、你可以经常用来把某些值改为临界情况 - 以查看当前页面在处理这些临界状况收的反应、这样比(找后端联调\找临界点的测试账号)这些数据成本要低得多， 截获IPhone上的网络封包 Charles通常用来截获本地上的网络封包、当我们需要时、可以用来截取其他设备上的网络请求，如下 截取IPhone上的网络请求、首先打开Charles的代理功能Proxy -&gt; Proxy Settings填入代理端口8888 并勾选&quot;Enable transparent HTTP proxying&quot; 完成在Charles上的设置 在手机上&quot;设置&quot; -&gt; &quot;无线局域网&quot; 找到当前链接的WIFI名、点击右侧详情( 感叹号 )，在最底部找到HTTP代理、修改成手动 设置 - 无线局域网 服务器：当前Charles运行所在电脑的IP：系统偏好设置 -&gt; 网络 选中现在连着的网（大部分人应该都是WiFi吧） ​ 服务器 ： 电脑IP地址 ，端口号: 8888， 设置完成后、打开iphone上的任意与需要网络的软件、就可以在Charles上看到弹出如下信息,点击&quot;Allow&quot;即可完成设置 - 这是会有一大波抓包信息的展示 模拟慢速网络 在开发时、我们常常需要模拟慢网速或者高延迟的网络、以测试在移动网络下、开发的产品是否显示正常 在Charles菜单中，选择&quot;Proxy - Throttle Setting&quot;在之后弹出的对话框中、勾选上&quot;Enable Throttling&quot;,并且可以设置不同网速的类型如下 修改网络请求内容 有时候伪类调试服务器的接口、我们需要反复尝试不同的参数的网络请求，Charles可以很方便的提供网络请求的修改和重发功能、在网络请求上点击右键,选择&quot;Edit&quot;,即可编辑 我们可以修改请求的任何信息 URL地址 端口号 参数 等等 之后点击&quot;Execute&quot;即可发送该修改后的网络请求。Charles支持我们多次修改和发送该请求，这对于我们和服务器端调试接口非常方便]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面操作iFrame的Dom]]></title>
      <url>%2F2016%2F11%2F18%2F%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9CiFrame%E7%9A%84Dom.html</url>
      <content type="text"><![CDATA[没有过时的技术只有变态的需求 contentWindow兼容主流浏览器、获取子窗口的window对象; 指定的frame或iframe所在的window对象 document对象是window对象的一个子对象; 123456789101112131415document.getElementById('iframe ID').contentWindow.document来获取iframe的document对象。相当于contentDocument属性document.getElementById('userIframe').onload = function()&#123;&#125;window.onload = function()&#123; // (LEPass &amp;&amp; LEPass.isLogin) 登录返回true、没登录放回false document.getElementById('userIframe').contentDocument.body.onclick = function(a)&#123; if(a.target.className == 'ntscshen' &amp;&amp; !(LEPass &amp;&amp; LEPass.isLogin()))&#123; // 登录内容信息 LEPass.openLoginPage(window.location.href, '', &#123; ... ... &#125;); &#125; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Atom编辑器的使用技巧]]></title>
      <url>%2F2016%2F10%2F08%2FAtom%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html</url>
      <content type="text"><![CDATA[在Atom中快速打开命令行实际开发的痛点：经常从编辑器切换到命令行( 虽然可以使用CmdTap类似的工具 )、但找到当前目录是需要花费很多时间 安装插件快速打开当前文件命令行目录 apm install open-terminal-here 打开当前项目的顶级目录alt-cmd-t 打开当前文件所在的位置ctrl-cmd-t 在Atom中新建文件、重命名、移动advanced-open-file alt-cmd-o 新建文件 shift-cmd-p rename重命名文件 ctrl-0 m 修改 a 添加文件 shift-a 添加文件夹 d 复制 自定义snippets.cson atom-ternjs Atom快捷键的使用关闭标签后 - 后悔ctrl-shift-t 样式表修改 Atom styless 树形视图的修改和浏览 cmd-\ 打开关闭树形试图( cmd-k-b ) 转移视图光标( ctrl-0 ) ctrl-[ 展开收缩 树形视图 ] ctrl-alt[ 递归展开收缩 ] J向上 k向下 展开目录 L 收起目录H 添加文件和目录 ctrl - 0 - add ( a ) 创建时候可以建立对应目录下的文件夹 ctrl-0 shift-a 创建目录 移动和重命名、复制粘贴删除 ctrl-0 move( m ) 移动到对应的文件目录下、可以用来重命名文件或者目录 duplicate( d )复制 APM 是atom package menage atom包管理工具 可以让用户在命令行下安装跟新删除编辑器的package apm search color 在命令行中显示对应的包 apm home color-picker 使用默认的浏览器打开对应包的首页 apm list包列表 Community packages 社区包 Built-in Atom packages Atom内置包 Snippets代码片段 alt+shift+s代码片段的介绍和一些简写形式 ATOM插件 - Community packages atom汉化atom-simplified-chinese-menu插件 tool bar插件 atom-ternjs JavaScript和Node自动补全插件 - 必备 highlight-selected 高亮所有和当前选中单词一样的单词，IDE标配。 autocomplete-paths 路径补全插件 linter** 和 linter-eslint** linter-eslint依赖linter，安装之后就可以按照.eslintrc文件里面配置校验JS了。 UI file-icons 高颜值的文件图标 pigments 代码颜色可视化修改颜色位置 Marker TYpe: dot indent-guide-improved 代码大括号范围提示。 minimap 类sublime的小地图功能 fold-comments 注释快速折叠 ctrl-shift-/ 快速注释会打出 顿号 elastic-tabstops 弹性制表位 highlight-selected 高亮所有和当前选中单词一样的单词 quick-highlight 高亮、同时高亮多处非选中的单词，在读代码时挺有用 highlight-line 高亮当前行 ​ IDE功能补全 emmet atom-ternjs 提供了了比较精确的代码补全功能ECMAScript、DOM/BOM、NodeJS autocomplete-paths 路径补全 advanced-open-file 翻遍的打开创建文件 cmd+alt+o autoclose-html 自动闭合标签 atom-beautify 代码美化、自己支持的语法不多、语法例如 PHP、MarkDown、Python 则需系统安装一些额外的插件 editorconfig 空格和utf-8、EditorConfig帮助开发人员保持不同的编辑器之间是一致的编码风格 Run In Browser 打开浏览器 ctrl + alt + r Bracket Matcher 括号匹配 docblockr 注释 autocomplete-emojis 表情包 Open Terminal Here 打开当前文件命令行 当前目录终端ctrl-cmd-t 项目目录终端alt-cmd-t regex-railroad-diagram package 正则 Activate Power Mode 爆炸 css-snippets javascript-snippets jQuery-snippets command palette dev live reload React hyperclick 可以跳转到变量定义的地方，也能识别import/require，点击模块名可以跳转到模块的内部。 js-hyperclick 配合 hyperclick 使用 Atom全局配置ESLinthttp://wrox.cn/article/100077190/ linter 和 linter-eslint Run in Browser ctrl + alt + R 打开浏览器 Atom Beautify ctrl + alt + B 格式化代码 ​ highlight-selected 自动补全 ​ emment autocomplete-paths 路径 扩展功能 chinese-menu 简体中文汉化 atom-beautify 格式化 Atom ternjs 代码补全 autoclose-html 自动添加结束标记 minimap 小地图 autocomplete-emojis 自动补全表情包 autocomplete-modules 自动补全模块路径 require(&#39;vue/js.js&#39;) autocomplete-paths 自动补全路径 docblockr 注释帮助包 Decorate 注释装饰 emment file-icons 文件扩展名图标和颜色以改善视觉体验 highlight-selected 高亮显示所选 quick-highlight 显示多个持久高亮 javascript-snippets js 片断 open-terminal-here 打开定位当前目录的终端 script 代码或者脚本运行 pigments css颜色 regex-railroad-diagram 正则铁路图 linter linter-eslint linter-csslint ​ ​ ​ editorconfig 编辑设置 帮助开发者在不同编辑器之间保持一致的编码风格 css和js语法检查 ​ ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端基础事件（一）]]></title>
      <url>%2F2016%2F09%2F22%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%BA%8B%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89.html</url>
      <content type="text"><![CDATA[移动端事件 touchstart 手指触摸屏幕时候触发 touched 手指离开屏幕时候触发 touchmove 手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。 addEventListener(‘事件名’,函数[匿名OR有名],false[冒泡和捕获]); DOM中提供的注册事件监听器的方法 它允许给一个事件注册多个监听器。不会存在前后覆盖问题 在Chrome的模拟器下可以一直识别 Event 事件对象、事件函数中默认的第一个参数 cancelBubble(取消冒泡) 阻止冒泡console.dir(event); target(标靶) 事件发生的位置console.dir(event); e.preventDefault();阻止默认事件 阻止页面中的文字选中 阻止页面上的系统菜单、滚动条失效、overflow: auto;失效 事件穿透 PC鼠标事件、但事件的执行会有300ms的延迟 点击了页面之后 - 浏览器会记录点击下去的坐标 300ms后、在该坐标找到现在在这的元素 - 执行事件 解决办法 e.preventDefault(); 阻止默认事件 不在移动端使用鼠标事件 不用a标签做页面跳转(点透问题、防止误触a标签)、把a标签的href的跳转e.preventDefault() 12345678910111213141516// 误触 document.addEventListener('touchstart', function(e) &#123; e.preventDefault(); &#125;) function mistake() &#123; this.isMove = true; &#125; var aBlock = document.querySelectorAll('a'); aBlock[0].addEventListener('touchmove', mistake, false); aBlock[0].addEventListener('touchend', function() &#123; if (!this.isMove) &#123; window.location.href = 'http://www.baidu.com'; &#125; this.isMove = false; &#125;, false);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[页面性能管理]]></title>
      <url>%2F2016%2F09%2F01%2F%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E7%AE%A1%E7%90%86.html</url>
      <content type="text"><![CDATA[网页生成的过程、大致分成五步 第一步到第三幕都非常快( 一刹那 ) “生成布局” - flow - layout(布局) - Render Tree( 渲染树 ) “绘制” - paint flow + paint = render(渲染) 重排和重绘 重绘：元素外观改变所触发的浏览器行为(visibility\outline\背景色) 重排：渲染树重新计算 “重绘”不一定”重排” “重排”必定”重绘” 从性能角度考虑 经量不把 读操作 和 写操作 在一个里面 12345// baddiv.style.left = div.offsetLeft + 10 + "px";// Goodvar left = div.offsetLeft;div.style.left = left + 10 + "px"; 一般规则如下 样式表越简单、重排和重绘就会越快 重排和重绘的DOM元素层级越高、成本就越高 table元素的重排和重绘成本、高于div元素 提高性能的技巧 读操作和写操作、应该放在一起( 不要在两个读操作之间、加入一个写操作 ) 若某个样式是通过重排得到的、把结果缓存下来、避免下一次用到的时候、浏览器重排 在需要经常获取那些引起浏览器重排的属性值时，要缓存到变量。 不要在JS里一条条的修改样式、要通过改变class或者csstext属性、一次性地改变样式 将元素设置display: none( 需要一次重排和重绘 )、然后对这个几点进行N+次操作、最后再回复显示( 需要一次重排和重绘 )、这样、使用两次重新渲染、取代可能的N+次的重新渲染 position属性为absolute或fixed的元素时候、重排的开销比较小、因为不用考虑它对其他元素的影响 123456// bad var top = 10; ele.style.left = left + "px"; ele.style.top = top + "px"; // Good var top = 10,left = 10; $('ele').css(&#123;left: left,top: top&#125;); css的效率 浏览器读取CSS选择器有一个很重要的原则，它们从右到左读取。这意味这像 ul &gt; li a[title=&quot;home&quot;]这样的选择器， a[title=&quot;home&quot;] 将是最先被读取的。 ID是唯一的、所以不需要任何的标签进行修饰、这样只会让效率更低ul#main{} 没有什么比用后代选择器更糟糕的做法了 后代选择器是css选择器里最昂贵的选择器 总结的优化技巧CSS优化 CSS尽量避免使用后代选择器 - 使用子代选择器代替没有比后代选择器跟糟糕的 在书写CSS时、使用类选择器”代替”元素选择器类选择器获取速度优于元素选择器 样式表越简单、嵌套层级越小( 重排和重绘就会越快 ) sass书写不大于三层 jQuery优化 选择器优化 尽可能使用ID选择器( 唯一的、最快的 )，因为jQuery源码中调用的是document.getElementById()、不要与其他选择器混搭 class选择器次之调用原生getElementByClassName()方法、指定类选择器的上下文、以缩小选择范围(默认：document)$(&#39;.class&#39;,&#39;#div1&#39;); 多级查找中、选择器的子类越详细越好$(&quot;.data li.li1&quot;) $parent.find(‘p.child’) 最快查找子元素的方法find()会调用原生的 getElementByTagName方法 经可能的缓存(缓存比不缓存快了2-3倍) 为什么要缓存得到的变量？就是减少访问DOM接口 使用链式写法、jQuery会自动缓存每一步的结果、链式比不链式写法快了25%左右 DOM优化 如果对一个DOM进行大量处理操作、使用.detach()方法、取出 - 处理 - 插入、使用.detach()方法比不使用时，快了60%。.detach(分离) .detach()移除被选元素，包括所有文本和子节点。这个方法会保留 jQuery 对象中的匹配的元素，因而可以在将来再使用这些匹配的元素。会保留所有绑定的事件、附加的数据。主要为了处理元素的大量DOM操作而生 改动DOM结构、先把它们合并，然后再一次性插入 不要使用匿名函数来用作事件处理、这样不利于调试、测试、维护和服用$(&quot;#btn&quot;).on(&#39;click&#39;,&#39;a&#39;,myClick);function myClick(){...} 在DOM元素上存储数据 123456var ele = $('#ele');ele.data(key,value);// 修改var ele = $('#ele');$.data(ele[0],key,value);// 因为elem.data()方法是定义在jQuery函数的prototype对象上面的，而$.data()方法是定义jQuery函数上面的，调用的时候不从复杂的jQuery对象上调用 如果可能的话使用自己的事件命名空间、这样方便地取消绑定而不影响其他的DOM元素事件绑定$(&quot;#myClick&quot;).on(&quot;click.ntscshen&quot;,&quot;a&quot;,myEventHandler);$(&quot;#myClick&quot;).off(&quot;click.ntscshen&quot;) 不要处理不存在的元素if($mySelection.length){...} 当某个事件后、如果要连续执行多个操作使用自定义事件并使用自执行事件 123456function shen()&#123; $.trigger('yang');&#125;$(document).on('yang',function()&#123; one();&#125;) 其他的优化方案 在JS内会用添加类名的方式修改”样式”属性不要使用jquery.CSS({方法})、使用添加类名的方式$(&quot;#click&quot;).addClass(&quot;error&quot;); 使用事件委托进行处理的方式就近原则 在注重性能的地方、请使用原生的Javascript代码 当需要大量的DOM操作时、先隐藏在内存中操作、在显示只触发两次重排和重绘操作 定位元素的开销较小、不用考虑对其他元素的影响]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[BFC]]></title>
      <url>%2F2016%2F08%2F31%2FBFC.html</url>
      <content type="text"><![CDATA[BFC - 快级格式化上下文 用于决定快盒子的布局及相互影响的区域 浮动 定位absolute OR fixed 行内快级元素display: inline-block 表格单元格display: table-cell 表格标题display: table-caption 切割overflow: hidden; 弹性盒子display: flex OR display: inline-flex 快级格式化上下文对定位和清除浮动很重要 定位和清除浮动的样式规则适用于处于同一个快格式化上下文内的元素 浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只清除同一块格式化上下文中 在它前面的元素的浮动。 BFC布局规则 内部元素会在垂直方向、一个接着一个放置 每个元素的margin box的左边、与包含快border box的左边相接触即使浮动也是如此 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 具体事务 BFC的区域不会与float box重叠 计算BFC的高度时、浮动元素也参与计算 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠上下margin值穿透 自适应两列布局1234567891011121314151617181920.box &#123; position: relative; width: 500px;&#125;.aside &#123; float: left; width: 100px; height: 200px; background-color: red;&#125;.main &#123; overflow: hidden; height: 300px; background-color: pink;&#125;/*overflow: hidden;会生成浮动BFC不会与浮动元素重叠实现自适应布局*/ 清除内部浮动(overflow: hidden;)12/* 计算BFC的高度时、浮动元素也参与计算 *//* 根据这个原理、清除浮动 */ 防止垂直margin重叠(一个BFC内的上下margin会重叠)12345678910111213141516171819/* Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻的Box的margin会发生重叠 */&lt;style&gt; p&#123; width: 200px; height: 200px; background-color: red; &#125; .wrap&#123; overflow: hidden; &#125;&lt;/style&gt;&lt;p&gt;111&lt;/p&gt;&lt;div class="wrap"&gt; &lt;p&gt;222&lt;/p&gt;&lt;/div&gt;/*在一个重叠的元素上包裹一层容器、并触发该容器生成一个BFC两个p标签就不属于同一个BFC、就不会发生重叠*/ BFC内部的元素和外部的元素”绝对”不会相互影响 BFC外部存在浮动时、它不应该影响BFC内部Box的布局、BFC会通过变窄、而不与浮动重叠 两列布局 BFC内部有浮动时、为了不影响外部元素的布局、BFC计算高度时会包括浮动的高度 清除浮动 BFC内部有重叠发生时、为了不影响外部元素的布局、BFC会包含margin值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css居中的几种方案]]></title>
      <url>%2F2016%2F08%2F31%2Fcss%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88.html</url>
      <content type="text"><![CDATA[固定宽高123456789.wrap &#123; width: 200px; height: 200px; background-color: red; position: absolute; left: 50%;top: 50%; margin-left: -100px; margin-top: -100px;&#125; 1234567891011.wrap &#123; width: 50%; height: 50%; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; background-color: yellow;&#125; 1234567891011.wrap &#123; width: 500px; height: 500px; background-color: chartreuse; display: table;&#125;.wrap div&#123; display: table-cell; vertical-align: middle; margin: 0 auto;&#125; 12345678910111213141516171819.box&#123; width: 500px; height: 500px; background-color: red; text-align: red;&#125;.box div&#123; /* 若为快级元素：则修改为display: inilne-block;即可 */ width: 200px; height: 200px; background-color: pink; vertical-align: middle;&#125;.box::after&#123; content:""; width: 1px; line-height: 500px; background-color: yellow;&#125; 不固定宽度123456789101112.box&#123; position: relative; width: 500px; height: 500px; background-color: red;&#125;.box .div1&#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);&#125; 12345678.box&#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; margin: auto;&#125; 12345678910111213/* 相对定位 + 浮动 */.box&#123; position: relative; float: left; left: 50%; top: 50%; background-color: yellow;&#125;.box li&#123; position: relative; left: -50%; top: -50%;&#125; 123456789.box&#123; position: absolute; left: 50%; background-color: red;&#125;.box li&#123; position: relative; left: -50%;&#125; 12345678910111213141516171819202122232425262728293031.box &#123; width: 500px; height: 500px; background-color: #77BBDD; /** 各种版本兼容**/ display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex; /** 垂直居中核心、兼容**/ -webkit-box-pack: center;//09版水平居中 -moz-box-pack: center; -ms-flex-pack: center;//过度版(混合版) -webkit-justify-content: center;//12版水平居中 justify-content: center; -webkit-box-align: center;//09版垂直居中 -moz-box-align: center; -ms-flex-align: center;//过度版(混合版) -webkit-align-items: center;//12版垂直居中 align-items: center; width: 0%;//低版本Android的flex-item无法等分 display: block; /* 实则只需三行 display: flex; justify-content: center; align-items: center; */&#125; 居中浮动元素1234567891011.box&#123; position: relative; left: 50%; top: 50%; float: left; margin-left: -100px; margin-top: -100px; width: 200px; height: 200px; background-color: red;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sass总结]]></title>
      <url>%2F2016%2F08%2F31%2FSass%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[变量 痛点：当配置样式时、需要重复修改各种类名的属性、这是是令人恼怒的 解决：类似于JS中的函数封装、哪里用到哪里调用、配置样式只需修改一次 变量定义在规则快之外 - 主样式内容之外 只声明变量其实没啥用处、最终的目的是达到样式可配置 凡是CSS属性的标准值存在的地方、变量都可使用 变量值也可以引用其他变量、通过颗粒度区分、为不同的值取不同的名字、这个规则相当有用 $highlight-color: #efe0ce !default;默认值 - 可配置修改、相当于jQuery的$.extend({},this.defaults,opt),this.defaults = {‘color’:’red’}, 变量名可以命名为属性名OR选择器名称、中划线和下划线可以相互混用 123456789$highlight-color: #efe0ce;$highlight-border: 1px solid $hightlight-color;.selected&#123; border: $highlight-border;&#125;// 编译.selected &#123; border: 1px solid #efe0ce;&#125; 文件导入.blue{@import &quot;blue-theme&quot;} 不能用sass的@import直接导入一个原始的css文件，因为sass会认为你想用css原生的@import。但是，因为sass的语法完全兼容css，所以你可以把原始的css文件改名为.scss后缀，即可直接导入了。 嵌套 痛点：css中重复写选择器是令人恼怒的、为了样式的不冲突需要一遍遍的写相同的ID 解决：sass的嵌套写法、只需写一遍、且可读性大大提高 在sass书写中会配到使用伪类元素情况:hover :after nth-child使用常规的嵌套方案会出现问题 正常的嵌套解耦是通过一个空格链接到子选择器的前面后代选择器 使用父选择器标示符&amp; 子组合选择器和同层组合选择器 123456789article&#123; ~ article&#123;border-top: 1px dashed #ccc;&#125; &gt; section &#123;background-color: #eee;&#125; dl &gt; &#123; dt&#123;color: #333;&#125; dd&#123;color: #555;&#125; &#125; nav + &amp; &#123;margin-top: 0;&#125;&#125; 属性嵌套 1234567891011nav &#123; border: 1px solid #ccc &#123; left: 1px; right: 1px; &#125;&#125;nav &#123; border: 1px solid #ccc; border-left: 1px; border-right: 1px;&#125; sass的条理性和可读性基础：变量、嵌套、导入、注释 混合器 痛点：整个网站中有几处小小的样式类似（例如一致的颜色和字体），那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。 通过@mixin example标示符定义、然后使用 @include example调用 大多数情况@extend可以满足日常的开发需求 而@include、较少使用的到e.g. 计算rem和px的装换 至于css3的前缀问题可以使用Autoprefixer插件在构建完成后自动添加 @include和@extend的区别 @include是用来调用@mixin的定义(包括) @extend(延伸) 继承选择器的样式 继承一个定义好的placeholder 相同之处：都可以給选择器添加一系列属性、而不用重复手写 不同之处： @extend会合并选择器、共享属性 @mixin每个选择器是独立存在的 修改伪元素 修改伪元素的content的属性值 12345678910// CSS代码.red::before &#123; content: attr(data-attr); color: red;&#125;// HTML代码&lt;div class="red" data-attr="red"&gt;内容内容内容内容&lt;/div&gt;// JacaScript代码$('.red').attr('data-attr', 'green'); 更改伪元素的样式1 12345678910111213// CSS代码.red::after&#123; content:"red", color: red;&#125;.green::after&#123; content:"green", color: green;&#125;// HTML代码&lt;div class="red"&gt;内容内容内容&lt;/div&gt;// jQuery代码$(".red").removeClass("red").addClass("green"); 更改伪元素的样式2 1234document.styleSheets[0].addRule('.red::before','color: green'); // 支持IE document.styleSheets[0].insertRule('.red::before &#123; color: green &#125;', 0); // 支持非IE的现代浏览器// styleSheets:返回由网页中所用到的样式表组成的数组，但是不包括直接嵌在元素里的style。 1$('&lt;style&gt;.red::before&#123;color:green&#125;&lt;/style&gt;').appendTo('head');]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css如何居中一个浮动元素]]></title>
      <url>%2F2016%2F08%2F30%2F%E6%AF%8F%E6%97%A5ES6%20-%20let%E5%92%8Cvar%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
      <content type="text"><![CDATA[let和var的区别 块级作用域：用let定义的变量只在定义它的块中有效 不会变量提升、为声明前使用、直接报错。 let会暂时性死区、一但快内let声明了a、全局变量a将不会起作用 let不允许在相同作用域内、重复声明同一个变量 为什么引进块级作用域？for循环的i变量控制循环、防止泄露在ES6之前 - JS没有块级作用域 12345678910111213141516// function要注意的规范// 应该避免在块级作用域内声明函数、如果确实需要、也应该写成函数表达式、而不是函数式声明// 函数式声明&#123; let a = "shen"; function f()&#123; return a; &#125;&#125;// 函数表达式&#123; let a = "yang"; let b = function()&#123; return a; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css如何居中一个浮动元素]]></title>
      <url>%2F2016%2F08%2F30%2F%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%ADdiv%EF%BC%9F%E5%A6%82%E4%BD%95%E5%B1%85%E4%B8%AD%E4%B8%80%E4%B8%AA%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0.html</url>
      <content type="text"><![CDATA[如何利用CSS居中一个浮动元素 居中一个浮动元素 宽度是必须的 使用相对定位 使用margin 1234567891011div&#123; position: relative;//相对于父级 left: 50%; top: 50%; float: left; margin-left: -100px; margin-top: -100px; width: 200px; height: 200px; background-color: red;&#125; 如何居中divcss中可以被继承的属性font-size、font-family、font-size、font-weight、color、text-indent、line-height、text-align、letter-spacing、word-spacing 文本相关属性 font-size、font-style、font-family、font-weight、font、 line-height、text-align、 text-indent首行文本缩进、letter-spacing单个字母间距、word-spacing以空白为分割间距 列表相关属性(li) list-style-type: decimal数字、circle空心圆、默认实心圆 list-style-position:inside放在文本以内且环绕文本 outside默认 list-style-image:使用图像来替换列表项的标记 缩写形式:list-style: decimal outside url(&#39;img/arror.gif&#39;); 颜色color 若被问到类似的问题 字体系列font-size\font-family\font-style\font-weight 字体颜色color 字体间距letter-spacing\word-spacing 列表系列list-style-image\type\position line-height\text-align\text-indent css中的选择器 常规选择器：ID\class\元素\ *通配符 伪类选择器： 动态伪类选择器:link\:visited\:active\:hover\:focus 状态伪类选择器 E:disabled{}匹配所有被禁言的表单元素 E:checked{}匹配表单中被选中的单选或复选按钮 E:enabled{}匹配被启用的元素(表单元素)checked反面 结构伪类 E:first-child选取特定元素的第一个子元素 OR last-child E:first-of-type(){} 和first-child一样、只是指定了元素类型 E:nth-child(n)选取特定元素的一个或多个子元素、n虫1开始、也可以是odd(奇数)，even(偶数)。E:nth-last-child(n) E:nth-of-type(n){}计算父元素中指定的某种类型的子元素 E:root匹配E所在文档的跟元素 E::first-line匹配元素的第一行文本、常用于文本排版 E::after E::before ::selection选中的文本背景颜色 关系选择器： A &gt; E 直系后代(children)子代选择器 A E 后代元素(find)后代选择器 E + F 同辈元素且在E后面的元素(next)相邻兄弟元素选择器 样式的优先级算法 - 优先级 内联 ID选择器 伪类选择器e.g: E:first-child{} 属性选择器e.g: input[type=&quot;text&quot;]{} 类选择器 元素选择器 通配符 !important除外]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抓包工具]]></title>
      <url>%2F2016%2F08%2F22%2F%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7.html</url>
      <content type="text"><![CDATA[抓包工具Win上的抓包 - Fiddler工具使用 Mac上的抓包 - Charles正版购买 Qi Tang’s Blog站的Charles使用心得 使用Charles、记录安装和使用 VPN 打开VPN之后、Charles将不会工作、因此撤掉VPN 设置端口并开启代理 确定工具栏下的 Proxy-&gt;Mac OS X Proxy被勾选上了 安装SSL证书 手机设置手机端和电脑链接在一个网段内，设置HTTP代理 然后打开手机浏览器，输入 http://www.charlesproxy.com/getssl/进行mac电脑charles ssl 根证书安装 安装成功之后不管是手机内部app还是浏览器浏览https 站点，都可以进行抓包]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[SSH Key到Github]]></title>
      <url>%2F2016%2F08%2F18%2F%E6%B7%BB%E5%8A%A0SSH%20Key%E5%88%B0Github.html</url>
      <content type="text"><![CDATA[添加ssh key到Github首先先确认是否已经存在公钥了( SSH Keys ) 1ls -al ~/.ssh 若存在id_rsa或id_rsa.pub。则代表已经生成过Key值、直接将SSH key添加到Github中 生成SSH 公钥1ssh-keygen -t rsa -C "注释内容，一般为邮件地址 xxx@163.com" 接着会显示以下的输出 123456789101112131415161718192021Generating public/private rsa key pair.Enter file in which to save the key (/Users/eguchi/.ssh/id_rsa): # &lt;输入Enter键&gt;Created directory '/Users/eguchi/.ssh'.Enter passphrase (empty for no passphrase): # &lt;输入验证密码&gt;Enter same passphrase again: # &lt;再输入一次相同的验证密码&gt;Your identification has been saved in /Users/eguchi/.ssh/id_rsa.Your public key has been saved in /Users/eguchi/.ssh/id_rsa.pub.The key fingerprint is:57:15:3c:ca:f2:dc:27:6d:c2:9a:88:d0:70:cf:8d:31 xxx@163.comThe key's randomart image is:+--[ RSA 2048]----+| .o. || .o || ... . || . . E.o || +So.O o . || . ..+ + = +|| . . . o = || . . o || |+-----------------+ 默认会在相应路径下~/.ssh生成id_rsa和id_rsa.pub两个文件 复制id_rsa.pub文件信息cat ~/.ssh/id_rsa.pub。将这些信息复制到Github的Add SSH key页面。 输出实例 123456ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDkkJvxyDVh9a+zH1f7ZQq/JEI79dVjDSG4RzttQwfK+sgWEr0aAgfnxdxQeDKxIxqI1SwyTY8oCcWzvpORuPqwbc7UWWPcCvbQ3jlEdN5jvwKM82hincEWwI3wzcnVg2Mn8dH86b5m6REDzwRgozQ3lqrgwGVlTvkHDFs6H0b/1PSrMXGppOP/QXGEVhZ6Hy4m3b1wMjjrbYwmWIeYklgoGHyrldhAaDYc33y7aUcRyFyq5DubtsLn2oj4K+1q36iviCHxCOri0FDmn2dzylRCI4S+A2/P7Y7rVfdT+8OWYKCBUs8lfjujghEtejqQmj9ikyGTEAW1zQCN7hVwYdjL xxx@163.com 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key: Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。 不同的操作系统，均有一些命令，直接将SSH key从文件拷贝到粘贴板中，如下：mac 12pbcopy &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard windows 12clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard linux 12345sudo apt-get install xclip# Downloads and installs xclip. If you don&apos;t have `apt-get`, you might need to use another installer (like `yum`)xclip -sel clip &lt; ~/.ssh/id_rsa.pub# Copies the contents of the id_rsa.pub file to your clipboard 错误处理1ssh -T git@github.com 超时报错 1ssh: connect to host github.com port 22: Operation timed out 让SSH走443端口解决方案 编辑~/.ssh/config文件(若没有、则创建一个)touch config vim config 123456789101112131415161718192021222324Host github.comUser ntscshen@163.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host gi.coding.netUser ntscshen@163.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443Host，SSH 连接名HostName，如上所示，可以是通配符，可以是 IP，也可以是域名等User，登录的用户名IdentifyFile， version 1 协议下默认是 ~/.ssh/identify， version 2 协议下，默认是依次匹配：~/.ssh/id_dsa，~/.ssh/id_ecdsa，~/.ssh/id_rsa， 还有 version 2 兼容模式。LocalForward 端口的内部跳转Port，端口设置，默认 SSH 的端口是 22 // 公司封github 22端口Protocal，协议版本号，1 或者 2 :wq 参数说明 ssh-keygen 用于为 ssh(1)生成、管理和转换认证密钥，包括 RSA 和 DSA 两种密钥。 密钥类型可以用 -t 选项指定。如果没有指定则默认生成用于SSH-2的RSA密钥。 -t type - 指定要创建的密钥类型。可以使用：”rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2) -C comment - 提供一个新注释]]></content>
    </entry>

    
  
  
</search>
